# 第13回 抽象化

抽象化は，状態爆発問題を軽減するための最も重要な技術の一つである． 
抽象化モデルは，関心のある性質に関係のないと思われるシステムのいくつかの詳細を隠すことによって得られ，通常，完全なモデルよりもはるかに小さくなる．
モデルのサイズが小さくなるため，元のモデルよりも抽象モデルの方が検証しやすくなることが多い．	

抽象化される前のシステムのモデルを具象 (concrete) モデルと呼ぶ． 
抽象化は通常，目的の性質に対して保守的であるように選択される．
つまり，抽象 (abstract) モデル上でその性質が成り立つときはいつでも，具象モデル上でも成り立つ．
ここでは，モデル検査を適用できるように，有限状態モデルを生成する抽象化のみを考える．
本章では上方近似 (over approximation) の抽象化に注目する．
このような抽象化には，具象モデルの各動作の代表が含まれる．
また，具象モデルには対応する動作がないような動作が追加されることもある．
しかし，通常，状態や遷移の数はより少なくなる．
その結果，このような抽象化されたモデルは，モデル検査が容易となる．
さらに，LTL や ACTL の性質，つまり普遍的な経路限定を持つ性質に対しては保守的であることが保証されている．

上方近似の抽象化を構築する最も自然な方法は，具象モデルの状態から抽象モデルの状態への写像を定義し，この写像を遷移に拡張することである．
このようにして，元のシステムをシミュレートし，通常よりはるかに小さい抽象モデルを得ることができる．
この抽象化手法は実存的抽象化 (existential abstraction) と呼ばれる．

次のセクションでは，実存的抽象化に基づく手法のうち，広く利用され，実際に実現可能な3つの実装を調査する．
Localization reduction [330] は，特にハードウェアモデルに適している．
これは，性質に無関係な変数を特定し，モデルから削除することにより，回路を抽象化する．
Data abstractions [134,361] では，個々の状態変数のドメインが抽象化される．
Predicate abstraction [252] では，述語の集合を特定し，その述語の評価で一致する具象状態を合体させる． 述語抽象とデータ抽象は，ソフトウェアモデルに最も適している．

上方近似の抽象化は，その性質が抽象モデルで真である場合にのみ結論が得られる．
しかし，その性質が失敗した場合，具体的なモデルではそれが偽であると推論することはできない．
これは，上方近似された抽象モデルにおける性質の反例が，具体的なモデルにおいて対応するものを持たない可能性があるからである．
このような反例を spurious または false negativesと呼ぶ．
そこで，その性質が具体的なモデルで本当に反証されることを示す，対応する具体的な反例があるかどうかを確認しなければならない．
もし，抽象的な反例が偽りであるとわかったら，その抽象化の欠点を指摘し，改良しなければならない．
この方法は，CEGAR(Counterexample-Guided Abstraction Refinement) と呼ばれる [132]．

## 13.1 Existential Abstraction
まず，明示的に与えられた具象モデルに依存する実存的抽象化の正式な定義から始める．
この定義は，抽象化が保守的であることを証明するために使われる．
しかし実際には，完全な具象モデルが大きすぎてメモリに収まらないような状況で，抽象化が必要となる．
そこで，システムの何らかの高水準な記述から直接，抽象モデルを構築することにする．
これについては13.2節で説明する．

具象モデルとしてクリプキ構造を $ M = (S, S_{0}, R, AP, L) $ と書くことを想起してほしい．
その抽象モデルはクリプキ構造 $ M = (\widehat{S}, \widehat{S_{0}}, \widehat{R}, \widehat{AP}, \widehat{L}) $ として定義される．$ \widehat{AP} $ は $ AP $ と同一とする．
いつものように，$ AP (\widehat{AP}) $ は，検査された性質 $ \varphi $ に現れるすべての原子命題を含む．

$ \widehat{M} $ を定義するためには，抽象的な状態の集合 $ \widehat{S} $ を用意する必要がある $ \widehat{S} $ の抽象状態のそれぞれは，$ S $ の具象状態の集合を表す．
ここでは，すべての具象状態は一意な抽象状態によって表現されると仮定する．
したがって，2つの異なる抽象状態が表現する状態の集合は不連続であり，具象状態をその抽象代表に写す抽象化関数 (抽象化関係ではない) を定義することができる．

$$
\alpha : S \rightarrow \widehat{S}
$$

我々は，各具象状態が，ある抽象的な状態によって表現されることを要求しており，これによって全体的な関数が構成される．
さらに，抽象化は $ \widehat{AP} $ の命題の評価について同意する場合のみ，状態をグループ化することを要求する．
この要件は，$ \alpha $ の適切性 (appropriateness) と呼ばれ，形式的には以下のように定義される．

#### 定義 13.1
!!! Abstract "定義 13.1"
    抽象化関数$ \alpha $ は，$ \alpha(s) = \alpha(s') $ を持つ具象状態 $ s $ と $ \widehat{s} $ のすべての組に対して $ L(s) = L(\widehat{s}) $ が成り立つ場合にのみ $ \widehat{AP} $ に適切とされる．

$ \widehat{AP} $ に対する $ \alpha $ の適切性によって，抽象状態のラベル付けを簡単に定義することができる．
抽象状態 $ \widehat{S} $ は，それが表す具体状態がその命題でラベル付けされていれば，$ \widehat{AP} $ の原子命題でラベル付けされるのである．

!!! Note "図13.1"
    $ M $ は元のクリプキ構造であり，$ \widehat{M} $ は抽象化されたものである．
    $ M $ の破線は，$ M $ の状態がどのように抽象的な状態にクラスタリングされるかを示している．
    具象状態と抽象状態は $ AP = \widehat{AP} = \{p, q\} $ でラベル付けされている．

図 13.1 に具象モデル $ M $ とその抽象化モデル $ \widehat{M} $ を示す．
$ M $ の破線は， $ S $ を抽象的な状態に分割したことを示す．
しかし，抽象モデルの遷移と初期状態の集合を定義しなければならない．
上方近似を求めるので、すべての具象遷移とすべての具象初期状態が抽象的な対応関係を持つことを保証する．
実存的抽象化では，抽象状態が具象状態の初期状態を表す場合，初期状態と定義する．
同様に，$ \widehat{S} $ で表される状態から $ \widehat{S'} $ で表される状態への遷移がある場合，抽象状態$ \widehat{S} $ から抽象状態 $ \widehat{S'} $ への遷移が存在することになる．
これは形式的には次のように定義される． 

!!! Abstract "定義 13.2"
    $ M = (S, S_{0}, R, AP, L) $ を（具体的な）クリプキ構造，$ \widehat{S} $ を抽象状態の集合、$ AP = \widehat{AP} $ を（抽象的な）原子命題の集合とする．
    さらに，$ \alpha : S \rightarrow \widehat{S} $ を $ \widehat{AP} $ に適した抽象化関数とする．
    クリプキ構造 $ M = (\widehat{S}, \widehat{S_{0}}, \widehat{R}, \widehat{AP}, \widehat{L}) $ は，以下が成立するとき，$ \alpha $ に関する $ M $ の実存的抽象化である．

    - もし $\exists s (\alpha (s) = \widehat{s} \wedge s \in S_{0})$ ならば $\widehat{s} \in S_{0}$ である；
	- もし $ \exists s_{1},s_{2} (\alpha (s_{1}) = \widehat{s_{1}} \wedge \alpha (s_{2}) = \widehat{s_{2}} \wedge (s_{1},s_{2}) \in R)$ ならば $ (\widehat{s_{1}},\widehat{s_{2}}) \in \widehat{R}$ である；
	- $\alpha (S) = \widehat{S}$ となる $s$ に対して $ \widehat{L} = (\widehat{S}) L(S)$ である．

非形式的には，抽象化された $ \widehat{M} $ は $ M $ よりも多くの動作を持つ．
これは， $ \widehat{M} $ が $ M $ よりもシミュレーションの前段階において大きいことを示す次の定理によって形式化される．
定理11.9によって， $ \widehat{M} $ について成り立つすべてのACTL*式は $ M $ についても同様に成り立つ．

#### 定理 13.3
!!! Abstract "定理 13.3"
    $ M $ をクリプキ構造とし，$ \widehat{M} $ を $ M $ の抽象化とすると $ M \preceq \widehat{M} $ となる．

!!! Note "証明"
    $ \widehat{M} $ を構成するのに使用した抽象化関数を $ \alpha $ とする．
    $ M $ と $ \widehat{M} $ の間の関係 $ H $ を与え，それがシミュレーションの関係であることを示す．
    すべての $ s \in S, \widehat{s} \in \widehat{S} $ に対して次式を定義する．
    $$
        (s, \widehat{s}) \in H \text{ iff } \alpha(S) = \widehat{s} ．
    $$
    まず，すべての $ s_{0} \in S_{0} $ に対して，$ (s_{0}, \widehat{s_{0}}) \in H $ を満たすような$ \widehat{s_{0}} \in \widehat{S_{0}} $ が存在することを示す．
    実存的抽象化の定義により，$ \alpha(s_{0}) $ は任意の初期状態 $ s_{0} $ に対して $ \widehat{M} $ の初期状態である．
    $ H $ の定義により，$ (s_{0}, \alpha(s_{0})) \in H $ となる．

    $ (s, \widehat{s}) \in H $ と仮定する．
    まず，$\widehat{AP} $ の表示について 2 つの状態が一致していることに注目してほしい．
    そうすると，$ L(s) \cap \widehat{AP} = \widehat{L}(\widehat{s}) $ となる．

    $ (s, t) \in R $ とする．
    我々は，$ (\alpha(s),\alpha(t)) \in \widehat{R} $ を示さなければならないが，これは実存的抽象化の定義から直ちに導かれる．

次の系は定理13.3と定理11.9の直接の帰結であり，抽象化の重要な特性である．

#### 系 13.3.1
!!! Abstract "系 13.3.1"
    $ AP $ 上のすべてのACTL*式 $ \varphi $ に対して， $ \widehat{M} \models \varphi $ は $ M \models \varphi $ を意味する．

系 13.3.1 は，$ \widehat{M} \models \varphi $ の場合，つまり，抽象モデル上で性質 $ \varphi $ が真となる場合にのみ，$ M $ に関する情報を提供する．
$ \widehat{M} \lnot \models \varphi $ の場合， $ M $ に関する情報は推論されない．
(この結論は，検証された特性が ACTL* にあることを仮定しているので，$ \widehat{M} \models \lnot \varphi $ でこの結論を導くことは不可能である．)
というのも，この式は検証された性質が ACTL* にあることを仮定しているからである．
このように，$ M $ は $ \widehat{M} $ よりも多くの ACTL* 特性を証明することができ，抽象化によって特性 $ \varphi $ を検証できるかどうかは抽象化関数 $ \alpha $ の選択に依存する．
抽象化が粗すぎる場合，つまりモデルの詳細を抽象化しすぎた場合，モデル検査器は (非常に迅速に) $ \widehat{M} \models \varphi $ と答えるかもしれない．
一方，抽象度が高すぎると (極端な話，$ \alpha $ は単なる恒等式かもしれない)，抽象モデルが大きくなりすぎて検証できなくなる．
その結果，抽象的なモデルには具体的な対応関係を持たない初期状態や遷移が許されるため，抽象 $ \widehat{M} $ は一意的には決まらない．
13.3.2 節では，CEGER のアプローチを示し，抽象化の中に徐々に詳細を追加していくことができるようにする．

もう一度定義 13.2 を考えて，1. および 2. の項目で \emph{if} を使ったことに注意してほしい．
その結果，抽象化モデル $ \widehat{M} $ は一意に決まらない．なぜなら，抽象化モデルでは，具体的な対応関係を持たない初期状態や遷移を持つことができるからである．
上の定義で \emph{if} を \emph{if and only if} に置き換えると，$ \alpha $ に関して，$ M $ の最も精密な (most precise) 抽象モデルが得られる．
この抽象的なモデルを $ \widehat{M_{p}} $ と表記する．
任意の抽象モデル $ \widehat{M} $ は，最も精密な抽象モデル　$ \widehat{M_{p}} $ を模倣 (simulate) する．
したがって，次の定理が成り立つ．

#### 定理 13.4
!!! Abstract "定理 13.4"
    モデル $ M $ 抽象化関数 $ \alpha $ が与えられたとき，$ \widehat{M} $ を $ M $ の抽象化，$ \widehat{M_{p}} $ を最も精密な抽象化とすると，いずれも $ \alpha $ に関して，$ M \preceq \widehat{M_{p}} \preceq \widehat{M} $ となる．

!!! Note "証明"
    明確に，$ M \preceq \widehat{M_{p}} $ が定理 13.3 の特殊な場合として成立する．
    $ \widehat{M_{p}} \preceq \widehat{M} $ を示すために，$ \widehat{S} $ 上の同一関数を $ H $ とする．定義によれば，$\widehat{M} $ と $ \widehat{M_{p}} $ は同じ抽象状態の集合に対して定義されている．
    さらに，$ \widehat{M} $ は $ \widehat{M_{p}} $ より多くの初期状態と遷移を持つ．
    従って，$ H $ は $ \widehat{M_{p}} $ と $ \widehat{M} $ の間の模倣関係である．


最も正確な抽象化は，一般に，具体的なモデルについてより多くの特性を証明することを可能にするが，計算コストも高くなる．

次節では，抽象化を定義するいくつかの一般的な方法について説明する．
これらはすべて実存的な抽象化の例である．
これらは，抽象状態 $ \widehat{S} $ の選択，原子命題の集合 $ \widehat{AP} = AP $ ，および抽象化関数 $ \alpha $ の定義が互いに異なる．
定義 13.2 が $\widehat{S_{0}}$, $\widehat{R}$, $\widehat{L}$ を提供しているので，これで十分である．

### 13.1.1 Localization Reduction

具体的なモデルの記述には，第 3 章で定義されたシステムの記号表現を用いる．
$ \varphi $ を変数の集合 $ V = \{v_{1},\ldots,v_{n}\} $ 上のシステムとし，$ D_{v} $ を $ v \in V $ の領域とする．
$ S = D_{v_1} \times \ldots \times D_{v_n} $ とする $ \varphi $ の具象モデルを $ M $ とする．
局所化削減 (localization reduction) [330] は，変数を可視変数と不可視変数に分割することに基づく抽象化技法である．
これはハードウェアのモデル検査に広く用いられている．

可視の変数（$ \mathcal{P} $ とする）は，チェックされた特性 $ \varphi $ にとって重要であると考えられるので，抽象モデルに保持される．
不可視変数と呼ばれる残りの変数は，$ \varphi $ のチェックに無関係であると考えられる．
理想的には，変数の小さな部分集合のみが可視となる．可視変数の集合は常に原子命題 $ \widehat{AP} $ に現れる変数を含む．

具体的な状態とは，$ \mathcal{V} $ の全変数の値であることを思い出して欲しい．
ここで，抽象状態 $ \widehat{s} \in \widehat{S} $ を可視変数の評価であると定義する．
可視変数の集合を $ \mathcal{P} = \{u_{1},\ldots,u_{q}\} \subseteq V $ とする．
そして、抽象状態の集合を$ \widehat{S} = D_{u_1} \times \ldots \times D_{u_q} $ とする．

具体的な状態 $ s $ に対応する抽象的な状態 $ \alpha (s) $ は，$ s $ を $ \mathcal{P} $ の変数に射影したものである．
$$
\alpha (s) = (s(u_{1}),s(u_{2}),\ldots,s(u_{q})) 
$$
抽象状態は，可視変数の値に関して同意するすべての具象状態を表します．

$ \mathcal{V} $ は $ \widehat{AP} $ に現れるすべての変数を含むので，$ \widehat{AP} $ の評価は同じ抽象状態にマッピングされるすべての具象状態において同じである．
従って，$ \widehat{AP} $ には $ \alpha $ が適当である．
$ \alpha $ が定義されると， $ \widehat{M} $ の残りの構成要素は定義 13.2 から導かれる．



#### Cone of Influence Reduction
次に，可視変数のセットについて，保守的 (conservative) な選択を紹介する．
ここでは，第 3 章 3.3 節のハードウェアのモデル化のためのいくつかの定義を繰り返す．
各変数 $ v \in V $ は次の状態関数 $ f_{v}(V) $ と関連付けられると仮定する．
一般に，$ f_{v} $ は $ V $ の部分集合にのみ依存する．
式 $ \varphi $ の Cone of Influence Reduction (COI) は帰納的に次のように定義される．
これは $ \varphi $ のすべての変数を含む．
また，$ v $ が COI にある場合，$ f_{v} $ が依存するすべての変数も COI にある．

$ \varphi $ の COI を可視変数の集合とすることで，$ \varphi $ に関して具象モデルと等価 (equivalent) な抽象モデルが得られる．
つまり，具象モデルが $ \varphi $ を満たす場合にのみ，抽象モデルも $ \varphi $ を満たす．
その結果，抽象モデルで $ \varphi $ に反論することは，具象モデルで反論することを意味する． 
しかし，この選択は COI が大きすぎるため，現実的でないことが多い．

13.2.2 節の例 13.10 は，Localization Reduction の削減がハードウェアに最も適している理由を示しています． 
ブール変数だけを考える場合，一部の変数の挙動を完全に不定にし (入力のように振る舞うという意味)，他の変数の挙動を完全に含めると便利なことがよくある． 
ソフトウェアの場合，変数のドメインが非常に大きいか，あるいは無限大になると，変数の振る舞いを完全に含めることが不可能になる場合がある．

Localization Reduction は，原理的には，無限領域を持つすべての変数を見えなくすることで，無限状態モデルを有限状態抽象モデルに抽象化することができる．
しかし，その結果得られる抽象化では，これらの変数に関するいかなる性質も証明することはできない．
次節では，無限領域を有限領域に写像し，無限領域の変数を推論できる抽象化手法を示す．

### 13.1.2 Data Abstraction

具体的なモデルは前節と同様に与えられると仮定する．
我々は，抽象領域がシステムの各変数に対して個別に選択される，特別な種類のデータ抽象化 [134, 361] を記述する．
抽象領域は通常有限であり，変数の元の領域よりかなり小さい．
具体的な状態に対する抽象化関数は，個々の変数に対する抽象化関数から構成される．

$ D_{v} $ は変数 $ v $ の具象領域を表すことを思い出してほしい．
$ v $ の抽象領域は $ D_{v} $， $ v $ の抽象化関数は $ \alpha_{v} : D_{v} \rightarrow \widehat{D_{v}} $ とする．
そして，抽象的な状態空間は，以下の式によって定義される．
$$
\widehat{S} = \widehat{D_{v_{1}}} \times \ldots \times \widehat{D_{v_{n}}}
$$
具象状態$ s = (d_{1},\ldots,d_{n}) $ に対して，抽象化関数 $ \alpha $ は次のように定義される．
$$
\alpha((d_{1},\ldots, d_{n})) = (\alpha_{v_{1}}(d_{1}),\ldots,\alpha_{v_{1}}(d_{n}))
$$

Data Abstraction は，変数が別々に抽象化されるため，完全な具象状態に対して定義される抽象化よりも計算が簡単な場合が多い．

#### 例 13.5
!!! Example "例 13.5"
    $ \mathcal{P} $ を整数上の変数 $x$ と $y$ を持つプログラムとする．
    $ AP = \widehat{AP} = \{x < 0, x = 0, even(y)\} $ とする．
    このとき，
    $$
    \widehat{D_{x}} = \{a_{-}, a_{0}, a_{+}\} \text{ and }
    $$
    $$
    \alpha_{x}(d) = \left\{ \begin{array}{lcr}
    a_{+} & \text{ if } d > 0 \\
    a_{0} & \text{ if } d = 0 \\
    a_{-} & \text{ if } d < 0 
    \end{array} \right .
    $$
    であり，
    $$
    \widehat{D_{y}} = \{a_{even}, a_{odd}\} \text{ and }
    $$
    $$
    \alpha_{x}(d) = \left\{ \begin{array}{lcr}
    a_{even} & \text{ if } even(|d|) \\
    a_{odd}  & \text{ if } odd(|d|) 
    \end{array} \right .
    $$	
    であるように選ぶことができる．
    $ s(x) = s(y) = 2, s' (x) = -7, s' (y) = 5 $ となる 2 つのプログラム状態を$ s, s' $ とする．
    このとき，$ \alpha (s) = (a_{+}, a_{even}), a(s') = (a_{-}, a_{odd}) $ とする．
    具体的な状態と抽象的な状態を図 13.2 に示す．
    なお，結果の $ \alpha $ は $\widehat{AP} $ に対して適切である．


各変数を単独で抽象化した場合，データ抽象化の適切性要件を満たすことは必ずしも容易ではない． 
$ \widehat{AP} $ の各原子命題が 1 つの変数だけを参照していれば，その変数に対して適切な抽象化領域を定義することは常に可能である．
抽象領域$ \widehat{D_{v}} $ は，$ v $ を参照する原子命題が引き起こす分割を利用して定義することができる．
この結果，例 13.6 に示すような適切な抽象化関数$ \alpha $が得られる．

一方，$ AP $ において，2 つ以上の変数を参照する原子命題がある場合，適切な抽象化関数をもたらす個々の変数の抽象領域を見つけることができない場合がある．
これには，複数の変数をまとめて抽象化したものを使用することで対応できる．
このような抽象化は relational abstraction (関係的抽象化) と呼ばれる [390][132]．
Data abstraction のような抽象化は non-relational (非関係的) と呼ばれる．
関係性抽象化の有名な例は octagon abstract domain (八角形抽象領域) [391] であり，$x$ と $y$　を変数，$c$ を定数とする $\pm{x} \pm{y} \leq c$ の形の制約を表現することができる．
もう一つの広く使われている関係的抽象化は Predicate Abstraction (述語抽象化) であり，これについては次に述べる．

### 13.1.3 Predicate Abstraction

述語抽象化 [252] は述語 $ {P_{1},\ldots,P_{k}} $ の集合に基づくもので，各 $ P_{i} $ は具象状態の部分集合である．
述語は通常，システムの変数上の原子的な一階論理式によって与えられる．

各述語 $ P_{j} $ はブール型状態変数 $ B_{j} $ と関連付けられている．
これらのブール変数は，抽象状態空間を定義する．
つまり，抽象状態 $ \widehat{s} \in \{0,1\}^{k} $ は　$ {B_{1},\ldots,B_{k}} $ の付値である．

述語は，具象状態空間を抽象状態空間に写像する抽象化関数 $ \alpha $ を定義する．
具象状態 $ s $ は，状態 $ s $ で評価されたときに $ B_{i} $ の値が述語 $ P_{i} $ の値と一致する抽象的な状態に写像される．
$$
\alpha(s) = (P_{i}(s),\ldots,P_{k}(s))
$$	
抽象状態 $ \widehat{s} $ における $ B_{i} $ の真理値を表すために $ \widehat{s}(B_{i}) $ と表記する．

適切性の要求を満たすために，$ \widehat{AP} $ のすべての原子命題 (したがって，性質 $ \varphi $ のすべての原子命題) が述語の集合に含まれることが要求される．
このとき，抽象状態 $ \widehat{s} $ は $\widehat{s}(B_{i}) $ の場合にのみ $ P_{i} \in \widehat{AP} $ とラベル付けされることに注意してほしい．

述語抽象化はプログラムによく適用される．
我々はこの場合の最適化については，第 14 章で詳しく説明する．

#### 例 13.6
!!! Example "例 13.6"
    上で定義された概念のいくつかを簡単な例で説明する．
    自然数上の変数 $ x $ と $ y $ を持ち，単一の遷移 $ x:= x + 1 $ を持つプログラム $ \varphi $ を考えよう．
    $ AP = \widehat{AP} = \{P_{1}, P_{2}, P_{3}\} $ とし，$ P_{1} \Leftrightarrow (x \leq 1), P_{2} \Leftrightarrow (x > y), P_{3} \Leftrightarrow (y = 2) $ とする．

    $s(x) = s(y) = 0$， $t(x) = 1$， $t(y) = 2$ となるような2つの具象状態を $s$ および $t$ とする．
    そして，$ L(s) = \{P_{1}\}$， $L(t) = \{P_{1}, P_{3}\} $ とする．
        
    抽象状態はブール変数 $ B_{1}, B_{2}, B_{3} $ の評価値で定義される．
    したがって，$ \widehat{S} = \{0,1\}^{3} $ となる．
    抽象化関数 $ \alpha $ は，$ s $ と $ t $ を以下の抽象状態に写像する．
    $$
    \alpha(s) = (1,0,0) \text{ and } \alpha(t) = (1,0,1)
    $$
    なお，$\widehat{L}((1,0,0)) = L(s) = \{P_{1}\}$ であり，$\widehat{L}((1,0,1)) = L(t) = \{P_{1}, P_{3}\}$ である．


## 13.2 Computation of Abstract Models
第 3 章では，システムの高位な記述から具体的なモデルを導出する方法を示した．
本章では，プログラムや回路記述のような高レベルのシステム記述から，抽象モデルを直接導出する方法を説明する．
具体的なモデルを構築することなく，抽象的なモデルを構築する．
第 3 章と同様に，特定のプログラミング言語やハードウェア記述言語の詳細を避けるため，システムは一次式によって記述されると仮定する．
念のため，3章で使用した例の一部を繰り返す．

### 13.2.1 Abstracting Software Programs
プログラムを $ \mathcal{P} $ とし，現在と次の状態を表すプログラム状態を $s, s'$ とする．
プログラムの具体的なモデルは，初期状態の集合と遷移の集合をそれぞれ記述する二つの一階論理式 $ \mathcal{S}(s), \mathcal{R}(s, s') $ で与えられると仮定する．
さらに，遷移関係は第 3 章で説明したように構築されるため，$ \mathcal{R} $ の構成的な構築を可能にするプログラムカウンタ $ pc $ を使用すると仮定する．

以下は，具体的なモデルを表す一次式の組み立てを説明するいくつかの簡単な例である．
プログラム中の各ステートメントは，プログラム中の対応する場所を一意に定義するラベルで始まり，終了する．
変数 $ pc $ はプログラムカウンタを表し，プログラムラベルの集合を網羅する．

#### 例 13.7
!!! Example "例 13.7"
    $ \mathcal{P} $ を $x$ が偶数である任意の状態のラベル $ l_{0} $ から始まる一つの変数 $x$ を持つプログラムとする．
    このとき，その初期状態の集合は次式で記述される．
    $$
    \mathcal{S}_{0}(pc, x) \equiv pc = l_{0} \wedge even(x)
    $$	

    $ l: x := e l' $ を $ \mathcal{P} $ のある代入文とする．
    この代入文に関連する遷移関係は次の式で表される．
    $$
    \mathcal{R}(pc, x, pc', x') \equiv pc = l \wedge x' = e \wedge pc' = l'
    $$
    という記述があることから，
    $$
    l_{0} : \textbf{if}  x = 0 \textbf{then} l_{1} : x := 1 \textbf{else} l_{2} : x := x + 1 \textbf{end if} l_{3}
    $$
    という式で表され，それに関連する遷移関係は
    \begin{eqnarray}
    \mathcal{R}(pc, x, pc', x') & \equiv & (pc = l_{0} \wedge x = 0 \wedge x' = x \wedge pc' = l_{1}) \nonumber \\
    & \vee & (pc = l_{0} \wedge x \neq 0 \wedge x' = x \wedge pc' = l_{2})  \nonumber \\
    & \vee & (pc = l_{1} \wedge x' = 1 \wedge pc' l_{3}) \nonumber \\
    & \vee & (pc = l_{2} \wedge x' = x + 1 \wedge pc' = l_{3}) \nonumber
    \end{eqnarray}

    上の式は，\textbf{if} 文の条件チェックに 1 回遷移し，その間にプログラム変数の値がチェックされるが変更されないモデルを記述している．
    また，この式はそれぞれ $ l_{1}, l_{2} $ と書かれた 2 つの代入文もモデル化している．

具象モデル $ M $ を記述する式を $ \mathcal{S}_0 $ と $ \mathcal{R} $ とする．
$ M $ と $ \alpha $ の定義 13.2 に従って定義された抽象モデル $ \widehat{M} $ についても，同様の記述を行いたい．
現在と次の具象状態に対する存在量化によって，$ S_{0} $ と $ \widehat{M} $を表す式 $ \mathcal{S}_{0} $ と $ \mathcal{R}_{0} $ を得ることができる：
$$
\widehat{\mathcal{S}_{0}}(\widehat{s}) = \exists s. (\alpha(s) = \widehat{s} \wedge \mathcal{S}_{0}(s)), \text{ and }
$$
$$
\widehat{\mathcal{R}}(\widehat{s}, \widehat{s'}) = \exists s \exists s'. (\mathcal{R}(s, s') \wedge \alpha(s) = s' \wedge \alpha(s') = \widehat{s'})
$$	

以下の補題は，これらの式で表されるモデルが，$ \alpha $ に関して最も正確な実存的抽象化であることを主張するものである．

#### 補題 13.8
!!! Abstract "補題 13.8"
    モデル $ M $ を記述する数式を$ \mathcal{S}_{0} $ と $ \mathcal{R} $ とする．
    このとき，式 $ \widehat{S_{0}} $ と $ \hat{\mathcal{R}} $ は，$ M $ と $ \alpha $ の最も精密な抽象モデルである $ \widehat{M}_{p} $ を記述する．

前述したように，抽象モデルの計算にはコストがかかる場合がある．
特に，プログラム全体の遷移関係を記述する式に実存的数量化を適用して計算を行う．
この式は，使用する一階論理の断片によっては，計算が非常に困難であったり，非常に大規模であったりする．

本論文では，ソフトウェアプログラムの抽象モデルの計算を簡略化する方法を紹介する．
この抽象モデルの重要な特性は，具体的プログラムの制御フロー骨格を複製することである．
すなわち，ラベル，分岐，ループ構造のセットを同じように使用する．
具体的プログラムのプログラムカウンタと同じラベルの集合にまたがる抽象的モデルのプログラムカウンタを導入する．
さらに，$ s(pc) = l $ となる状態 $ s $ は，$ s'(pc) = l $ となる抽象的な状態に抽象化される．

$ \widehat{\mathcal{R}} $ の作り方を説明する前に，$ \mathcal{R} $の形状を観察しておきます．
この点を説明するために，先程の例の続きをする．
まず，ド・モルガンの法則を用いて$ pc = l $ の項を因数分解することで， \textbf{if} 文のエンコードを書き換えることができることに注意する．

\begin{align}
& \mathcal{R}(pc, x, pc', x') \equiv \nonumber \\ 
& (pc = l_{0} \wedge ((x = 0 \wedge x' = x \wedge pc' = l_{1}) \vee (x \neq 0 \wedge x' = x \wedge pc' = l_{2}))) \vee \nonumber \\ 
& (pc = l_{1} \wedge x' = 1 \wedge pc' = l_{3}) \vee \nonumber \\
& (pc = l_{2} \wedge x' = x + 1 \wedge pc' = l_{3}) \nonumber
\end{align}	

文のラベルは一意であることを想起してほしい．
その結果，$ \mathcal{R}(s, s') $ は次のような形になる．
$$
R(s, s') \Leftrightarrow \underset{l}{\bigvee}(s(pc) = l \wedge conjunct_{l}(s, s') \eqno(13.1)
$$
ここで，論理和の $ l $ は全てのプログラム位置の範囲であり，$ conjunct_{l} $ は位置 $ l $ の命令のみに依存する任意の選言肢 (conjunct) を表す．
上記の例では，次のようになる．

\begin{eqnarray}
conjunct_{l_{0}}(pc, x, pc', x') & \equiv & (x = 0 \wedge x' = x \wedge pc' = l_{1}) \vee \nonumber \\
& ( & x \neq 0 \wedge x' = x \wedge pc' = l_{2}) \nonumber \\
conjunct_{l_{1}}(pc, x, pc', x') & \equiv & \ x' = 1 \wedge pc' = l_{3} \nonumber \\
conjunct_{l_{2}}(pc, x, pc', x') & \equiv & \ x' = x + 1 \wedge pc' = l_{3} \nonumber 
\end{eqnarray}	
これは $ \mathcal{R} $ の同値性保存変換 (equivalence-preserving transformation) であることを指摘する．
さらに，存在量化を論理和に押し込むと，同値性が保存されることを思い出してほしい．
これは次の補題で利用される重要な性質である．

#### 補題 13.9
!!! Abstract "補題 13.9"
    $ \mathcal{R}(s,s') $を次のような形の遷移関係とする．
    $$
    \underset{l}{\bigvee}(s(pc)) = l \wedge conjunct_{l} (s, s{\prime}) ．
    $$
    このとき，$ s $ と $ s' $ に対する存在量化を論理和に押し込むと，最も正確な existential abstraction が得られる．
    $$
    \widehat{R}(\widehat{s}, \widehat{s'}) \equiv \underset{l}{\vee} (\widehat{s}(pc) = l \wedge \exists s \exists s'. (conjunct_{l}(s, s') \wedge \alpha(s) = \widehat{s} \wedge \alpha(s') = \widehat{s'})) \eqno(13.2)
    $$

!!! Note "証明"
    存在量化を論理和に押し込むことで， 
    $$
        \widehat{R}(\widehat{s}, \widehat{s'}) \equiv \underset{l}{\vee} \exists s \exists s'. (\widehat{s}(pc) = l \wedge conjunct_{l}(s, s') \wedge \alpha(s) = \widehat{s} \wedge \alpha(s') = \widehat{s'}) \eqno(13.3)
    $$
    を得る．
    13.3 式をさらに単純化して 13.2 式を得るには，$ conjunct_l $ がプログラムカウンタに依存しないため，13.3 式の 2 つの接続詞が不連続な変数集合を使うことを観察すればよい．
    これにより，数量化を接続詞に押し込むことができる．
    さらに，$ \alpha(s) = \widehat{S} $ である任意の $ s $ と $\widehat{S} $ の組に対して $\widehat{S}(pc) = (pc) $ であることを思い出してほしい．

この補題の利点は何だろうか？
存在量化は遷移関係の個々の部分に対して行われ，その部分の大きさはプログラムの大きさに依存しないことに注意してほしい．
そうすると，$ \widehat{R} $ の計算は，ラベルの数で測定される $ \mathcal{P} $ のサイズに対して線形になる．

続けて，実行例を交えて説明する．
プログラムの最初の文では，次のような量化を行う必要がある．
\begin{eqnarray}
\exists s \exists \widehat{s}. \alpha(s) = \widehat{s} \wedge \alpha(\widehat{s}) = \widehat{s'} \wedge ((s(x) = 0 \wedge \widehat{s}(x) = s(x) \wedge \widehat{s}(pc) = l_{1}) \vee (s(x) \neq 0 \wedge \widehat{s}(x) = s(x) \wedge \widehat{s}(pc) = l_{2})) \nonumber
\end{eqnarray}	
特定の抽象化関数 $ \alpha $ に対するこの実数の計算は，演習として残しておく．

### 13.2.2 Abstracting Synchronous Circuit with Localization Reduction
ソフトウェアの場合と同様に，初期状態の集合と遷移関係の計算のための existential quantification を避けるために，回路の高位記述から直接抽象モデルを導出することを目指す．

まず，第 3 章に示した回路の高レベルな説明を思い出してほしい．
回路はレジスタと一次入力である変数 $ V = \{v_{1},\ldots,v_{n}\} $ の集合を持つ．
また，モデルの遷移関係 $ M $ の特性関数である命題式 $ \mathcal{P}(V, V') $ が与えられている．
我々は $ \mathcal{P} $ を以下のように接続詞を用いて定義した．
$$
R(V, V') \equiv \underset{i = 1}{\overset{n}{\bigwedge}} R_{i}(V, V')
$$
$ \mathcal{P}_{i} $ の定義は，$ v_{i} $ がレジスタか一次入力かによって異なる．
$ v_{i} $ がレジスタの場合，ブール式 $ f_{i} $ が与えられ，$ v_{i} $ の次の状態を変数の現在値の関数として計算する．
そして $ \mathcal{P}_{i} $ は次のように定義される．
$$
R_{i}(V, V') \equiv (v_{i}' \Leftrightarrow f_{i}(V))
$$
$ v_{i} $ が一次入力の場合，$ \widehat{V'} $ を無制約にする．
つまり，$ \mathcal{P}_{i} $ を真と定義すると
$$
R_{i}(V, V') \equiv true
$$
ここで，$ R $ が満たすべき条件を思い出すと
$$
(\widehat{s}, \widehat{s'}) \in \widehat{R} \equiv \exists s, s'. (\alpha(s) = \widehat{s} \wedge \alpha(s') = \widehat{s'} \wedge (s, s') \in R)
$$

Localization Reduction では，変数の集合を可視変数の集合と不可視変数の集合に分割する．
可視変数の集合を $ \mathcal{V} \subseteq V $ とする．
$ \mathcal{V} $ に含まれない変数は不可視である．
不可視変数の集合を $ \mathcal{U} $ と表記する．
具体的状態 $ s $ は，このように可視変数 $ \mathcal{V} $ と $ \mathcal{U} $ の評価であるのに対し，抽象的状態 $ \hat{s} $ は，変数 $ \mathcal{V} $ のみの評価である．
したがって，抽象化関数 $ \alpha $ は，可視変数と不可視変数を用いて，以下のように記述される．
$$
\alpha(\mathcal{V}, \mathcal{U}) = \mathcal{V}
$$

ここで，変数 $ \mathcal{V} $ とその次の状態のバージョン$\mathcal{V'}$の間の関係として，抽象的な遷移関係 $ \widehat{\mathcal{R}} $ を定義する．
\begin{eqnarray}
\widehat{\mathcal{R}}(\widehat{\mathcal{V}}, \widehat{\mathcal{V'}}) \equiv \exists \mathcal{V}, \mathcal{U}, \mathcal{V'}, \mathcal{U'} .& ( & \;\; \alpha(\mathcal{V}, \mathcal{U}) = \widehat{V'} \nonumber \\
& \wedge & \alpha(\mathcal{V'}, \mathcal{U'}) = \widehat{\mathcal{V'}}) \nonumber \\
& \wedge & \mathcal{R}(\mathcal{V}, \mathcal{U}, \mathcal{V'}, \mathcal{U'})) \nonumber
\end{eqnarray}	

定義では，見えない変数の値を実存的に定量化しており，あたかもそれらが一次入力であるかのように振る舞うことを意味している．
$ \alpha $ の定義を用いると，上記は以下のように単純化される．
$$
\widehat{\mathcal{R}}(\widehat{\mathcal{V}}, \widehat{\mathcal{V'}}) \equiv \exists \mathcal{U}, \mathcal{U'} . \mathcal{R}(\hat{\mathcal{V}}, \mathcal{U}, \hat{\mathcal{V'}}, \mathcal{U'})
$$
$ \mathcal{R} $ の定義を用いると，次のようになる．
$$
\widehat{\mathcal{R}}(\widehat{\mathcal{V}}, \widehat{\mathcal{V'}}) \equiv \exists \mathcal{U}, \mathcal{U'} . \underset{i = 1}{\overset{n}{\bigwedge}} \mathcal{R}_{i}(\widehat{\mathcal{V}}, \mathcal{U}, \widehat{\mathcal{V'}}, \mathcal{U'})
$$
可視変数と不可視変数のケースを区別するために，接続詞を分割した．
$$
\widehat{\mathcal{R}}(\widehat{\mathcal{V}}, \widehat{\mathcal{V'}}) \equiv \exists \mathcal{U}, \mathcal{U'} . \underset{v_{i} \in \mathcal{V}}{\bigwedge} \mathcal{R}_{i} (\widehat{\mathcal{V}}, \mathcal{U}, \widehat{\mathcal{V'}}) \wedge \underset{v_{i} \in \mathcal{U}}{\bigwedge} \mathcal{R}_{i}(\widehat{\mathcal{V}}, \mathcal{U}, \widehat{\mathcal{U'}}) ．
$$
この式の中で $ \widehat{\mathcal{U'}} $ が使われているのは右の接続詞の部分だけである．
したがって，この式は次の式と等価である．
$$
\widehat{\mathcal{R}}(\widehat{\mathcal{V}}, \widehat{\mathcal{V'}}) \equiv \exists \mathcal{U} . \underset{v_{i} \in \mathcal{V}}{\wedge} \mathcal{R}_{i}(\widehat{\mathcal{V}}, \mathcal{U}, \widehat{\mathcal{V'}}) \bigwedge \exists \mathcal{U}' . \underset{v_{i} \in \mathcal{U}}{\bigwedge} \mathcal{R}_{i}(\widehat{\mathcal{V}}, \mathcal{U}, \widehat{\mathcal{U'}}) ．
$$
$ v_{i} $ の値は $f_{i}(\widehat{\mathcal{V}}, \mathcal{U}) $ で与えられるので，次の状態での不可視変数の評価は常に存在する．
したがって，この式を簡略化すると，
$$
\widehat{\mathcal{R}}(\widehat{\mathcal{V}}, \widehat{\mathcal{V'}}) \equiv \exists \mathcal{U} . \underset{v_{i} \in \mathcal{V}}{\bigwedge} \mathcal{R}_{i}(\widehat{\mathcal{V}}, \mathcal{U}, \widehat{\mathcal{V'}}) ．
$$

したがって，$ \widehat{R} $ には可視レジスタの次状態関数を残しておけばよく，不可視レジスタの接続詞は削除すればよい．
同値性保存の変換のみを使用したことに注意すると，この抽象化は最も正確な実存的抽象化である．

#### 例 13.10
!!! Example "例 13.10"
    例として，ネットリストで示された順序回路を考えてみよう ( 図 13.3 )．
    ネットリストは，ブール関数を計算するゲートをノードとし，ブール変数をエッジとする有向グラフである．
    ネットリストには x と y という名前の2つのレジスタがあり，入力には $ i_{1} $ と $ i_{2} $ という記号が付けられている．
    破線はグラフの切れ目を表し，可視変数と不可視変数を分離している．
    図 13.3 は，右側の抽象的なネットリストを示しており，カットによって取り除かれた変数が入力となり，それらを駆動するネットリストの部分が削除されている．
    抽象的なモデルは，抽象的なネットリストから直接導かれる．

## 13.3 Counterexample-Guided Abstraction Refinement (CEGAR)

### 13.3.1 Spurious Counterexamples
どのような抽象化を行ったとしても，抽象モデル $ \widehat{M} $ は具象モデル $ M $ よりも情報量が少ないことは容易に理解できる．
従って，$ \widehat{M} $ をモデル検査すると，誤った結果が得られる可能性がある．
定理 13.3 は，$ \widehat{M} $ において $ ACTL' $ 仕様が真であれば，$ M $ においても真であることを保証する．
一方，以下の例は，抽象モデルが $ ACTL' $ 仕様を無効にしても，実際のモデルが仕様を満たす可能性があることを示す．


#### 例 13.11
!!! Example "例 13.11"
    図 13.4 に示す米国の信号機制御装置は，状態 $S=\{red, green, yellow\}$ と原子命題の集合 $AP=\{state = red\}$ に対して定義されており， $state = red$ は赤で真，緑と黄で偽となる．
    $ \varphi = \textbf{AGAF}(state =red) $ という式を証明したい．
    そのために，$ \widehat{AP} = AP $ と $ \widehat{S} = \{\widehat{red}, \widehat{go}\} $ を選択する．
    抽象化マッピングの $ \alpha(red) = \widehat{red} \; and \; \alpha(green) = \alpha(yellow) = \widehat{go} $ を使用する．
    抽象モデルにおける遷移は，実存的抽象化 ( 定義 13.2 ) により定義される．
    例えば，赤から緑への遷移があるので $ \widehat{red} $ から $ \widehat{go} $ への遷移があり，緑から黄色への遷移があるので $ \widehat{go} $ から $ \widehat{go} $ への遷移がある．


$ \widehat{M} \lnot \models \psi $ であるのに対し，$ M \models \psi $ であることは容易に理解できる．
仕様を無効にする無限抽象トレース $ \langle\widehat{red}, \widehat{go}, \widehat{go},\ldots\rangle $ が存在する．
しかし，それに対応する具体的なトレースは存在しない．

抽象的な反例が具体的な反例に対応しない場合，それを spurious と呼ぶ．
たとえば，上の例の $ \langle\widehat{red}, \widehat{go}, \widehat{go},\ldots\rangle $ は偽反例 (spurious counterexamples) である．

図 13.5 のような状況を考えてみよう．
抽象的な経路 $ \langle\widehat{a_{1}}, \widehat{a_{2}}, \widehat{a_{3}}\rangle $ には対応する具体的な経路がないことがわかる. 
初期状態からの具体的な経路はすべて状態 $ D $ に行き着き，そこから先には進めない. 
したがって，$ D $ は行き止まり状態と呼ばれる．
一方，$ B $ は送信遷移があると思わせてしまったので，悪い状態 (bad state) である．
最後に，状態 $ I $ は行き止まりでもなければ悪い状態でもないので，無関係な状態である．
例えば，図 13.5 の太線で示すように，行き止まりの状態と悪い状態を分離することで，偽の経路を排除することができる．
$ \widehat{M} $ の抽象化(太い矢印で示す)は spurious である．
そのため，$ M $ の太い線で示したように，抽象度を上げなければならない．

### 13.3.2 The Abstraction-Refinement Framework for ACTL\*
本節では，論理ACTL*と実存的抽象化に関する CounterExample-Guided Abstraction-Refinement (CEGAR) [132] の枠組みを紹介する. 
CEGAR フレームワークの主要なステップは以下の通りである．

1. 初期状態の抽象化を行う.モデル $ M $と ACTL* 式 $ \varphi $ が与えられたら，前節で説明したように，初期抽象モデル $ \widehat{M} $ を生成する．
2. 抽象構造をモデル検査するため，$ \widehat{M} $ を $ \varphi $ に関してモデル検査する．
既存のモデル検査ツールの多くは，ACTL または LTL を扱うことができる ( いずれもACTLの部分集合である.)
もし $ \varphi $ が真であれば，具体的なモデルが公式を満たしていると結論づけ，停止する．
3. 偽の反例を識別する．
反例 $ \widehat{T} $ が見つかった場合，それが具体的なモデルにおける反例と一致するかどうかを確認する．
この部分については，13.3.3 節で説明する．
もしそうなら，具体的なモデルが式を満たさないと判断し，中止する．
そうでなければ，その反例は偽であり，改良が必要であるため，手順4へ進む．
4. 抽象化を洗練させるため，$ \widehat{T} $ が新しい抽象モデルに含まれないようにする．
通常，$ \widehat{T} $ に沿って抽象状態を分割し，それに応じて $ \alpha $ を適宜更新することにより，改善されたモデルを得ることができる．
この部分については，13.3.4 節で説明する．
新しく改善された抽象的なモデルを構築し，ステップ 2 に戻る．


最初の抽象化および改良を手作業で提案するには，多大な工夫と検証されたシステムに関するかなりの知識が必要となる．
プログラムテキストから自動的に（最初の）抽象化モデルを構築する方法については既に述べたとおりである．
以下では，[132] に従って，spurious な反例を用いて改善点を自動的に決定する方法を示す．

### 13.3.3 Identifying Spurious Counterexamples
$ \widehat{M} $ が仕様 $ \varphi $ を満たすかどうかはモデル検査で判断する．
$ \widehat{M} $ が $ \varphi $ を満たさず，モデル検査器が反例 $ \widehat{T} $ を生成したとする．
ここでは，有限パスである安全性特性の反例に注目する．
また，本節の最後に，有限パスの後にループが続く活性特性の反例を簡単に説明する．

反例 $ \widehat{T} $ をパス $ \langle\widehat{S_{1}},\ldots,\widehat{S_{n}}\rangle $ と仮定する．
抽象状態 $ \widehat{s} $ が与えられたとき，$\alpha(s) = \widehat{s} $ となる具象状態$ s $ の集合を$ \alpha^{-1} (\widehat{s}) $ と表記する．
つまり，
$$
\alpha^{-1} (\widehat{s}) = \{s \mid \alpha(s) = \widehat{s} \}．
$$
$ \alpha^{-1} $ を配列に拡張すると次のようになる．
$ \alpha^{-1} (\widehat{T}) $ は以下の式で定義される具象パスの集合である．
$$
\alpha^{-1} (\widehat{T}) = \{<s_{1},\ldots,s_{n}> \mid \underset{i = 1}{\overset{n}{\wedge}} \alpha(s_{i}) = \widehat{s_{i}} \wedge S_{0}(s_{1}) \wedge \underset{i = 1}{\overset{n-1}{\wedge}} R(s_{i}, s_{i+1})\}．
$$
$ \widehat{T} $ は$ \alpha^{-1} (\widehat{T}) $ が空の場合にのみ spurious であることに注意してほしい．
次に，$ \alpha^{-1} (\widehat{T}) $ が空であるかどうかを判断するために使用できる具体的な状態の集合 $ <T_{1},\ldots,T_{n}> $ の順序を定義する．

- $ T_{1} = \alpha^{-1}(\widehat{s_{1}}) \cap S_{0} $
- $ T_{i} = Image(T_{i-1}) \cap \alpha^{-1}(\widehat{s_{1}}) \; for \; 1 < i \leq n $

$ Image(T_{i-1}) $ は$ T_{i-1} $ における状態のすべての後状態の集合であることを思い出して欲しい．
次の補題は，$ \alpha^{-1} (\widehat{T}) $ が空であるかどうかを判断するために使われる．

#### 補題 13.12
!!! Abstract "補題 13.12"
    以下は等価となる．

    1. 具象パスの集合 $ \alpha^{-1} (\widehat{T}) $ は空でない．
    2. すべての $ 1 < i \leq n $ に対して，$ T_{i} = \varnothing $ である．

!!! Note "証明"
    (1 $\rightarrow$ 2) 
    $ \alpha^{-1}(\widehat{T}) $ が空でないと仮定する．
    すると，$ \alpha(S_{i}) = \widehat{S_{i}}, s_{1} \in S_{0} $ となるパス $ \langle s_{1},\ldots,s_{n}\rangle $ が存在する．
    よって，$ S_{1} \in T_{1} $ がある．
    ここで，$ s_{i} \in T_{i} $ とする．
    $ \alpha^{-1}(\widehat{T}) $ の定義により，$ S_{i+1} \in Image(S_{i}) $ と $ S_{i+1} \in \alpha^{-1}(\widehat{S_{i+1}}) $ が存在する．
    よって，$ S_{i+1} \in Image(T_{i}) \cap \alpha^{-1}(\widehat{S_{i+1}}) = T_{i+1} $ となる．
    帰納法により，$ i \leq n $ のとき，$ T_{i} = \varnothing $ となる．

    (2 $\leftarrow$ 1) 
    全ての $ i \leq n $ について，$ T_{i} = \emptyset $ と仮定する．
    状態 $s_{n} \in T_{n} $ を選び，帰納的にトレースを後ろ向きに構成する．
    $ s_{i} \in T_{i} $ と仮定する．
    $ T_{i} $の定義から，$ s_{i} \in Image(T_{i-1}) \cap \alpha^{-1}(\widehat{S_{i}}) $ であり，$ T_{i-1} $ は空でないことがわかる．
    $ T_{i-1} $ から $ R(s_{i-1}, s_{i}) $ となるような$ s_{i-1} $を選択する．
    $ T_{i-1} $ の定義から，$ T_{i-1} \subseteq \alpha^{-1}(\widehat{S_{1}} \cap S_{0}) $ ．
    よって，$ S_{i-1} \in \alpha^{-1}(\widehat{S_{i-1}}) $ となる．
    帰納法により，$ s_{1} \in T_{1} = \alpha^{-1}(\widehat{s_{1}}) \cap S_{0} $ となる．
    よって，構築したトレース $ <s_{1},\ldots,s_{n}> $ は $ \alpha^{-1}(\widehat{T}) $ の定義を満たす．
    よって，$ \alpha^{-1}(\widehat{T}) $ は空ではない．

補題 13.13 の条件 2 が成立する場合，補題の証明は具体的な反例を構築するためのアルゴリズムを提供する．

ここで条件 2 に違反したとし，$ T_{j} \neq \emptyset $ となる最大のインデックスを $ j $ とすると，$ \widehat{S_{j}} $ は sprious counterexample $ \widehat{T} $ の失敗状態と呼ばれる．
補題 13.12 から， $ \alpha^{-1} (\widehat{T}) $ が空なら ( つまり反例 $ \widehat{T} $ が偽なら )，$ T_{j} = \varnothing $ のような最小の $ i$ および$1 \leq i \leq n $ が存在することが判る．
	
次の例では，図 13.6 に示すような抽象的な反例とその具体的な対応策を調査します．
使用する抽象化は data abstraction である．

#### 例 13.13
!!! Example "例 13.13"
    領域 $ D = \{1, \ldots, 12\} $ を持つ変数が 1 つしかないプログラムを考えると，具体的な状態は $ S = \{1, \ldots, 12\} $ のみである．
    $ S_{0} = {1, 2, 3} $ とする．
    抽象領域は $ D' = \{\widehat{1}, \widehat{2}, \widehat{3}, \widehat{4}\} $ であり，抽象化関数 $ \alpha $ は $ d \in D $ を $ \lfloor(d-1)/3 \rfloor + 1 $ へ写すとする．
    具象状態 $ \{1, 2, 3\}, \{4, 5, 6\}, \{7, 8, 9\}, \{10, 11, 12\} $ の 4 つの集合を表す $ \widehat{1}, \widehat{2}, \widehat{3}, \widehat{4} $ の 4 つの抽象状態が存在する．
    図 13.6 に示すように，具象モデルにおける状態間の遷移は矢印で示されており，小さな点は到達不可能な状態を示している．

    抽象的な反例 $ \widehat{T} = \langle\widehat{1}, \widehat{2}, \widehat{3}, \widehat{4}\rangle $ を得たとする．
    $ \widehat{T} $ が偽であることは容易にわかる．
    補題 13.12 の用語を用いると，$ T_{1} = \{1, 2, 3\}, T_{2} = \{4, 5, 6\}, T_{3} = \{9\}, T_{4} = \emptyset $ となる．
    $ T_{4} $ は空であるから，抽象状態 $ \widehat{3} $ は失敗状態である．

補題 13.12 に基づき，図 13.7 のアルゴリズム $SplitPATH$ は，抽象的な連続体サンプル $ \widehat{T} $ が存在するかどうかを判定する．
$ \widehat{T} = \langle\widehat{S_{1}},\ldots,\widehat{S_{n}}\rangle $ が与えられると，$SplitPATH$ は失敗状態のインデックス $ j-1 $ と状態集合 $ T_{j-1} $ を計算する．
もし $ T_{i} $ が空でなければ，$SplitPATH$ は「本当の」反例を報告し，中止することができる．

モデル検査で返される反例が，ループが続く有限のパスで構成されている場合にも，同様の解析が可能である．
この場合，解析は補題 13.12 を適用するために必要なループの巻き戻しの数の上限を提供する．
図 13.7 で説明したアルゴリズム $SplitPATH$ は，巻き戻された反例が spurious かどうかを判断するために使用することができる．
詳細は，[132] に記載されている．

行き止まり状態の検出後，次節で説明するように，絞り込みのステップに進む．

### 13.3.4 Refining Abstract Models
この節では，偽の反例を排除するために，抽象化されたモデルを改良する方法を説明する. 説明を簡単にするために，まず，抽象モデルが $ M $ と $ \alpha $ に対して最も正確なものであると仮定する. (定義 13.2 以降の議論を参照)
次に，必ずしも最も正確でない抽象モデルの扱い方を説明し，具象モデルが有限である場合，絞り込みの手順の数はせいぜい有限であることを証明する．

偽の反例を $ \widehat{T} $ とし，$ \widehat{T} $ 上の不具合の状態を $ \widehat{s_{i}} $ とする．
$ \alpha^{-1}(\widehat{s_{i}}) $ の部分集合を3つ定義する．

- $ \alpha^{-1}(\widehat{s_{i}}) $ において，$ \alpha^{-1}(\widehat{T}) $ の経路で到達可能だが，$ \alpha^{-1}(\widehat{s_{i}+1}) $ への遷移がない状態の集合を行き止まり状態$ S_{D} $と定義する．
- 不良状態 $ S_{B} $ の集合は，$ \alpha^{-1}(\widehat{s_{i}+1}) $ において，$ \alpha^{-1}(\widehat{T}) $ のパスに沿って到達できないが，$ \alpha^{-1}(\widehat{s_{i}+1}) $ への発信遷移を持つすべての状態の集合である．
- 無関係状態の集合 $ S_{I} $ は，$ \alpha^{-1}(\widehat{s_{i}+1}) $ に含まれるすべての状態のうち，$ S_{D} \cup S_{B} $ に含まれない状態の集合である．

この改良は，行き止まり状態 $ S_{D} $ の集合を不良状態 $ S_{B} $ の集合から分離するように，故障状態の分割を提案する．

我々はすでに行き止まりの状態を持っている．
$ S_{D} $ はまさに，アルゴリズム $SplitPATH$ によって返される集合 $ T_{j-1} $ である．
このアルゴリズムはまた，失敗状態に遭遇した反例におけるインデックスである$ j - 1 $ を返す．
状態の集合が与えられたとき，その集合の状態の前任者の集合を返す $ PreImage $ 演算子を使用する．
これで，以下のように不良状態を計算することができる．

$$
S_{B} = PreImage(\alpha^{-1}(\widehat{s_{j+1}}) \cap \alpha^{-1}(\widehat{s_{j}}))
$$

ここで，$ \widehat{s_{j}} $ 状態を分割して，$ S_{D} $ と$ S_{B} $ を分離する必要がある．
実際の分割は $ \alpha^{-1}(\widehat{s_{j}}) $ に適用されるが，表記を少し乱用して $ \widehat{s_{j}} $ の分割と呼ぶことにする．
このような分割方法は様々である．
例えば，$ \widehat{S} $ に新しい抽象状態 $ \widehat{s_{j}'} $ を追加し，$ S_{D} $ の状態が新しい $ \widehat{s_{j}'} $ に対応付けられるように $ \alpha $ を更新することが可能である．
あるいは，例えば新しい述語の形で，失敗状態の分割の基準を得ることができる．
そうすることで，絞り込み処理の収束を早めることができる．
このように，絞り込み処理の反復回数と抽象モデルの大きさは相反するものである.抽象状態を分割する改善方法を spliting-refinement と呼ぶ．
新しい $ \widehat{S} $ と $ \alpha $ が決まれば，$ \widehat{R}, \widehat{S_{0}}, \widehat{L} $ を更新する必要がある．

次に，$ M $ の抽象的なモデルが最も正確なものであるとは限らない場合について，議論を拡張する．
この場合，反例 $ \widehat{T} = \langle\widehat{s_{1}}, \ldots, \widehat{s_{n}}\rangle $ が偽である理由が2つ追加される．

- $ \widehat{T} $ の初期状態 $ \widehat{s_{1}} $ は初期具象状態を表現していない．
したがって，$ T_{1} = \alpha^{-1}(\widehat{s_{1}}) \cap S_{0} $ は空である．
$ \widehat{s_{1}} $ を疑似初期状態と呼ぶことにする．
この場合，絞り込みにより，抽象初期状態 $ \widehat{S_{0}} $ の集合から $ \widehat{s_{1}} $ を排除する．
- $ \widehat{s_{i}} $ から $ \widehat{s_{i+1}} $ への抽象的な遷移は，具体的なモデルには対応する遷移がない．
つまり，$ \alpha^{-1}(\widehat{s_{i}}) $ の状態から$ \alpha^{-1}(\widehat{s_{i+1}}) $ の状態への遷移は存在しない．
このような遷移を spurious tramsition と呼ぶ．
この場合，$ \widehat{R} $ から $ (\widehat{s_{i}}, \widehat{s_{i+1}}) $ のペアを削除する．

#### 例 13.14
!!! Example "例 13.14"
    図 13.6 の抽象的な反例と，例 13.13 で説明したものとは多少異なる具体的なモデルを再び考えてみてほしい．

    - 状態 1，2，3 が具体的な初期状態でない場合， $ \widehat{1} $ は疑似初期状態であり，$ \widehat{S_{0}} $ から削除されることになる．
    - 状態 7 から状態 12 への具体的な遷移がない場合，抽象的な遷移 $ (\widehat{3}, \widehat{4}) $ は spurious であり，$ \widehat{R} $ から削除されることになる．

モデル $ M $ と式 $ \varphi $ が与えられたとき，CEGER アルゴリズムの絞り込みステップ ( ステップ 4 ; 13.3.2 節参照 ) は，以下のように詳細に記述することができる．

<ul style="list-style-type: none;">
<li style="text-indent: -1.5em;">4a. \(\mathit{SplitPATH}\) が "spurious initial state" を返した場合，\( \widehat{S_{0}} \) から \( \widehat{s_{1}} \) を排除してステップ 2 へ進む．</li>
<li style="text-indent: -1.5em;">4b. 失敗状態を \( \widehat{s_{i}} \) とする．
    不良状態の集合 \( S_{B} \) が空であれば，遷移 \( (\widehat{s_{i}}, \widehat{s_{i+1}}) \) は spurious である．
    \( \widehat{R} \) からそれを取り除き，ステップ 2 へ進む．</li>
<li style="text-indent: -1.5em;">4c. そうでなければ，splitting-refinement を適用する．
    得られた抽象化関数を \( \alpha \) とする．
    \( M \) と \( \alpha \) の抽象モデルを構築する.（最も正確なものでなくてもよい）
    ステップ 2 へ進む．</li>
</ul>

なお，最初の 2 つのケースでは，$ \alpha $ は変化しない．
しかし，ステップ 4c では$ S_{D} $ と $ S_{B} $ が空でないときのみ適用されるため，変更が保証される．

一般に，具体的なモデルが無限状態である場合，CEGER の終了は保証されない．
以下の定義は，$ M $ が有限状態である場合，CEGER は有限個の精密化ステップのみを含むことを提供するために使用される．
まず，抽象化関数 $ \alpha : S \rightarrow \widehat{S} $ が具体的な状態の集合 $ S $ にパーティション $ P_{\alpha} $ を誘導することを見ていく．

$$
P_{\alpha} = \{ \alpha^{-1}(\widehat{s}) \mid \widehat{s} \in \widehat{S} \; and \; \alpha^{-1}(\widehat{s}) \neq \emptyset \}．
$$

これらの集合は分割されたものであり，不連続である．
さらに，$ \alpha $ は全数なので，すべての具体的な集合はある集合に帰属する．
ここで，抽象化関数が引き起こす分割に基づいて，抽象化関数の順序を定義する．

#### 定義 13.15
!!! Abstract "定義 13.15"
    $ \alpha_{1} : S \rightarrow \widehat{S_{1}} $  と $ \alpha_{2} : S \rightarrow \widehat{S_{2}} $ を$ M $ 上の 2 つの抽象化関数とする．
    以下が成り立つとき，$ \alpha_{2} $ は $ \alpha_{1} $ より小さく，$ \alpha_{1} < \alpha_{2} $ とする．
    - すべての $ S_{2} \in P_{\alpha_{2}} $ に対して，$ S_{2} \subseteq S_{1} $ を満たすような $ S_{1} \in P_{\alpha_{1}} $ が存在する．
    - $ S_{2} \subset S_{1} $ となるような $ S_{2} \in P_{\alpha_{2}} $ と $ S_{1} \in P_{\alpha_{1}} $ が存在する．

我々の設定では，$ \alpha_{2} $ が $ P_{\alpha_{1}} $ のパーティションを分割する精密化手順によって得られる場合，$ \alpha_{2} < \alpha_{1} $ の順で使用する．

以下の定理は，CEGER が終了することが保証される条件を述べている．

#### 定理 13.16
!!! Abstract "定理 13.16"
    有限状態モデル $ M $ と，反例がパスまたはループである $ ACTL $ または $ LTL $ 仕様 $ \varphi $ が与えられたとき，CEGER は $ \widehat{M} \models \varphi \Leftrightarrow M \models \varphi $ となるようなモデル $ \widehat{M} $ を見出す．

!!! Note "証明"
    CEGER において一連の洗練されたステップを経て得られた$ M $ の抽象モデルの系列を$\widehat{M_{1}}, \widehat{M_{2}},\ldots $ とする．
    ある $ \widehat{M_{i}} $ について仕様 $ \varphi $ が成り立つか，反例が non-spurious であることが分かれば，アルゴリズムは停止し，我々は終了する．

    そうでなければ，有限回の精密化ステップの間に，$ M $ と同型の抽象モデルを得ることを示す．

    まず，どの $ \widehat{M_{i}} $ も有限であるから，有限個の疑似初期状態と疑似遷移しか含まないことに注意してほしい．
    したがって，ある $ \alpha_{j} $ に対して最も正確なモデル $ \widehat{M_{j}} $ を得る前に，タイプ 4a および 4b の改善ステップを有限回だけ適用することができる．

    $ \widehat{M_{j}} $ が最も正確な場合，改善されたステップは必ず$ \alpha_{j+1} < \alpha_{j} $ を導くことを示す．

    $ \widehat{M_{j}} $ は最も精密なので，$ \alpha^{-1}(\widehat{s}) = \emptyset $ の抽象状態 $ \widehat{s} $ は $ \widehat{M_{j}} $ に到達しないため，反例に含まれることはない．
    したがって，アルゴリズム $SplitPATH$ は空でない失敗状態を返し，これはステップ 4c で精緻化される．
    絞り込みは，失敗状態と，場合によっては追加の抽象状態を分割する．
    したがって，$ P_{\alpha_{j+1}} $ におけるすべてのパーティションは $ P_{\alpha_{j}} $ におけるあるパーティションの部分集合であり，$ P_{\alpha_{j+1}} $ における少なくとも 1 つのパーティションは $ P_{\alpha_{j+1}} $ におけるパーティションの適切な部分集合である．
    その結果，$ \alpha_{j+1} < \alpha_{j} $ となる．

    その結果，$ \widehat{s_{i}} $ の上にモデル $ \widehat{M_{i}} $ が定義され，すべての抽象状態が 1 つの具象状態を表すようになるまでに，有限回のステップ 4c を適用することができる．
    さらに，$ \widehat{M_{i}} $ を最も正確にするために必要なステップ 4a および 4b は有限個だけである．
    この段階で，抽象モデルは具象モデルに同型となり，定理が成立する．

## 書誌情報
抽象化に関する調査が [138] の Dams と Grumberg による章にある．

また，抽象的なものを構築するというテーマは，抽象的解釈の理論 [163][162][167][360] の中心的なテーマの一つであるが，この章では扱わない．

最も広く使用されている抽象化には，主にハードウェ アに使用される Localization Reduction [330] と [43]，ソフトウェアに適している Predicate abstraction[252] がある．
ソフトウェア検証における Predicate abstraction の拡張，改良，応用は広く研究されている[42][40][141][52][142][53][119]．
また，ハードウェア検証 [293]，Linux デバイスドライバの並列検証 [491]，逐次検証 [383, 368] にも適用されている．
ハードウェア検証における様々な種類の抽象化の初期の分類は [385] に記載されている．

### Bisimulation and simulation
モデル上の同値関係の概念とそれに関連する論理の保存は多く定義されている；例えば，[268, 175, 176, 460]を参照．
シミュレーション関係と $ \mu $ -calculus の保存性との関係は，[360] で確立されている．

### Predicate abstraction
重要な問題は，必要な述語をどのように計算するかである．
これは，例えば，theorem provers[437][436]，symbolic decision procedures [337]，interpolation [294]，interpolation sequence[270][482] を用いて行うことができる．

いくつかの研究は，改善によって生じる抽象的なモデルのサイズの増大を避けようとするものである．
例えば，Lazy abstraction は，必要なときに必要な場所にだけ新しい述語をモデルに追加する[271][270][383][319][483][485]．

### CEGAR
$ \alpha $ の種類と$ M $ の大きさに応じて，初期の抽象モデル(すなわち，抽象的な初期状態と抽象的な遷移)は，BDDs，SAT solvers，またはtheorem provers を用いて構築することが可能である．
同様に，絞り込みで行われる抽象状態の分割は，BDD (例えば [132] や [41] のように)，SAT solvers (例えば [107][353][292] のように)，線形計画法や機械学習 (例えば [137] のように) などを用いて行うことが可能である．

ここでは，有限パスの反例に注目する．
[139] と [447] では，それぞれ ACTL と CTL の全てに対する反例が扱われている．

反例によらないハードウェアの反復抽象化ベース検証手法が [384] で紹介されている．

### Three-valued model checking
この章では，他の多くの抽象化のアプローチをカバーしない．
それらは通常，より精緻な抽象的なモデルに基づいている．
このようなモデルは，例えば，抽象状態が具象状態の非分離集合を表現することを可能にする．
また，具体的な遷移関係を過不足なく近似し，完全分岐時間論理の真理を保持する 2 種類の遷移を許容するものもある．
また，3 値意味論で数式を解釈し，完全分岐時間論理の真偽を保持することができる.これらのアプローチについては，Dams and Grum berg による [138] の章に記載がある．
