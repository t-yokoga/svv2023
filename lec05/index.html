
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.1.5">
    
    
      
        <title>第5回 - システム検証論 (2020)</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.21aed14c.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.196e0c26.min.css">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/earlyaccess/notosansjp.css">
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:600,800">
    
      <link rel="stylesheet" href="../css/custom.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#5-ctl" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href=".." title="システム検証論 (2020)" class="md-header-nav__button md-logo" aria-label="システム検証論 (2020)">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            システム検証論 (2020)
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              第5回
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="システム検証論 (2020)" class="md-nav__button md-logo" aria-label="システム検証論 (2020)">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    システム検証論 (2020)
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../lec01/" class="md-nav__link">
      第1回
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../lec02/" class="md-nav__link">
      第2回
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../lec03/" class="md-nav__link">
      第3回
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../lec04/" class="md-nav__link">
      第4回
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        第5回
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" class="md-nav__link md-nav__link--active">
      第5回
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ctl" class="md-nav__link">
    CTL* の部分論理
  </a>
  
    <nav class="md-nav" aria-label="CTL* の部分論理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ctl_1" class="md-nav__link">
    分岐時間論理 CTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#actl-actl" class="md-nav__link">
    全称計算木論理 ACTL* および ACTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ltl" class="md-nav__link">
    線形時相論理 LTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ctl_2" class="md-nav__link">
    CTL* の部分論理の関係性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    集合原子命題と集合意味論による時相論理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    公平性
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    反例
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    安全性と活性
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    演習問題
  </a>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#ctl" class="md-nav__link">
    CTL* の部分論理
  </a>
  
    <nav class="md-nav" aria-label="CTL* の部分論理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ctl_1" class="md-nav__link">
    分岐時間論理 CTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#actl-actl" class="md-nav__link">
    全称計算木論理 ACTL* および ACTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ltl" class="md-nav__link">
    線形時相論理 LTL
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ctl_2" class="md-nav__link">
    CTL* の部分論理の関係性
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    集合原子命題と集合意味論による時相論理
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    公平性
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    反例
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    安全性と活性
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    演習問題
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="5-ctl">第5回 CTL* ベースのその他の時相論理</h1>
<p>この回では，教科書の第4章 "Temporal Logic" の後半部分について説明します．</p>
<div class="admonition 概要">
<p class="admonition-title">概要</p>
<ul>
<li>分岐時間論理 CTL</li>
<li>全称計算木論理 ACTL* および ACTL</li>
<li>線形時間論理 LTL</li>
<li>CTL* の部分論理の関係性</li>
<li>集合原子命題と集合意味論に関する時相論理</li>
<li>公平性</li>
<li>反例</li>
<li>安全性と活性</li>
</ul>
</div>
<h2 id="ctl">CTL* の部分論理</h2>
<p>これから，CTL* の重要な部分論理のいくつかについて説明する．
この部分論理のうち，CTL，ACTL*，そして ACTL は<strong>分岐時間</strong>論理であり，LTL は<strong>線形時間</strong>論理である．
これらの論理は，文法的にも意味的にも，以下のように CTL* の部分集合となっている．</p>
<p><center>
<img src="../img/lec05-fig1.png" width="400">
</center></p>
<p>分岐時間論理と線形時間論理の違いは，計算木の分岐をどのように扱うかというところにある．
分岐時間の時相論理では，計算木の様々な状態を起点としたパスを，繰り返しパス限定子によって量化できる．
一方で，線形時間の時相論理では，初期状態を起点としたパスの全てを，一つの全称パス限定子で量化するのみである．</p>
<p>この 4 つの部分論理はいずれも CTL* の文法に制約を設けることで定義されるものなので，意味論も前回述べた CTL* の意味論に従って定義される．
ただ，CTL のように制限された文法に基づいて，直接（等価な）意味論を定義した方がわかりやすい場合もある．
以下，4 つの論理の文法について説明する．</p>
<h3 id="ctl_1">分岐時間論理 CTL</h3>
<p>計算木論理 (computation tree logic) CTL は CTL* の部分論理で，常にパス限定子と時相演算子が組となって現れる．
したがって，文法は以下のようになる．</p>
<ul>
<li><strong>B1</strong>: <script type="math/tex">p \in AP</script> ならば，<script type="math/tex">p</script> は CTL 式である．</li>
<li><strong>B2</strong>: <script type="math/tex">f</script> が CTL 式ならば，<script type="math/tex">\neg f</script>, <script type="math/tex">\textbf{AX} f</script>，<script type="math/tex">\textbf{EX} f</script>，<script type="math/tex">\textbf{AF} f</script>，<script type="math/tex">\textbf{EF} f</script>，<script type="math/tex">\textbf{AG} f</script>，<script type="math/tex">\textbf{EG} f</script> も CTL 式である．</li>
<li><strong>B3</strong>: <script type="math/tex">f</script> と <script type="math/tex">g</script> が CTL 式ならば，<script type="math/tex">f \wedge g</script>，<script type="math/tex">f \vee g</script>，<script type="math/tex">\textbf{A}(f\textbf{U}g)</script>，<script type="math/tex">\textbf{E}(f\textbf{U}g)</script>，<script type="math/tex">\textbf{A}(f\textbf{R}g)</script>，<script type="math/tex">\textbf{E}(f\textbf{R}g)</script> も CTL 式である．</li>
</ul>
<p>これから <strong>CTL 式の部分式</strong>というときは，この CTL の文法に従った部分式を指すことにする．
例えば，CTL 式 <script type="math/tex">\textbf{AXEX}p</script> の部分式は，<script type="math/tex">\textbf{AXEX}p</script>，<script type="math/tex">\textbf{EX}p</script>，そして <script type="math/tex">p</script> である．
CTL 式の部分式はすべて状態論理式となる．
仮に <script type="math/tex">\textbf{AXEX}p</script> を CTL* 式として見る場合，パス論理式である <script type="math/tex">\textbf{XEX}p</script>，<script type="math/tex">\textbf{X}p</script> も部分論理式となる．</p>
<p>CTL は，<script type="math/tex">\textbf{AX}</script>，<script type="math/tex">\textbf{EX}</script>，<script type="math/tex">\textbf{AF}</script>，<script type="math/tex">\textbf{EF}</script>，<script type="math/tex">\textbf{AG}</script>，<script type="math/tex">\textbf{EG}</script>，<script type="math/tex">\textbf{AU}</script>，<script type="math/tex">\textbf{EU}</script>，<script type="math/tex">\textbf{AR}</script>，<script type="math/tex">\textbf{ER}</script> という 10 個の複合した時相演算子をもつ論理と考えることもできる．</p>
<p>実際は，この 10 種の演算子は <script type="math/tex">\textbf{EX}</script>，<script type="math/tex">\textbf{EG}</script>，<script type="math/tex">\textbf{EU}</script> の 3 つの演算子を用いて表現できる．</p>
<p>
<script type="math/tex; mode=display">\begin{eqnarray*}
\textbf{AX} f & \equiv & \neg \textbf{EX}(\neg f) \\
\textbf{EF} f & \equiv & \textbf{E}(true \textbf{U} f) \\
\textbf{AG} f & \equiv & \neg \textbf{EF}(\neg f) \\
\textbf{AF} f & \equiv & \neg \textbf{EG}(\neg f) \\
\textbf{A}(f \textbf{U} g) & \equiv & \neg \textbf{E}(\neg g \textbf{U} (\neg f \wedge \neg g)) \wedge \neg \textbf{EG}(\neg g) \\
\textbf{A}(f \textbf{R} g) & \equiv & \neg \textbf{E}(\neg f \textbf{U} \neg g)\\
\textbf{E}(f \textbf{R} g) & \equiv & \neg \textbf{A}(\neg f \textbf{U} \neg g)
\end{eqnarray*}</script>
</p>
<p>したがって，CTL は <script type="math/tex">\textbf{EX}</script>，<script type="math/tex">\textbf{EG}</script>，<script type="math/tex">\textbf{EU}</script> という 3 つの演算子に基づく論理として，以下の意味論によって定義できる．</p>
<ol>
<li>
<script type="math/tex">M, s \models p</script>
<script type="math/tex">\Leftrightarrow</script>
<script type="math/tex">p \in AP</script> に対して <script type="math/tex">p \in L(s)</script>
</li>
<li>
<script type="math/tex">M, s \models \neg f_1</script>
<script type="math/tex">\Leftrightarrow</script>
<script type="math/tex">M, s \nvDash f_1</script>
</li>
<li>
<script type="math/tex">M, s \models f_1 \vee f_2</script>
<script type="math/tex">\Leftrightarrow</script>
<script type="math/tex">M, s \models f_1</script> または <script type="math/tex">M, s \models f_2</script>
</li>
<li>
<script type="math/tex">M, s \models f_1 \wedge f_2</script>
<script type="math/tex">\Leftrightarrow</script>
<script type="math/tex">M, s \models f_1</script> かつ <script type="math/tex">M, s \models f_2</script>
</li>
<li>
<script type="math/tex">M, s \models \textbf{EX} f</script>
<script type="math/tex">\Leftrightarrow</script>
<script type="math/tex">R(s, t)</script> かつ <script type="math/tex">M, t \models f</script> となる状態 <script type="math/tex">t</script> が存在する．</li>
<li>
<script type="math/tex">M, s \models \textbf{EG} f</script>
<script type="math/tex">\Leftrightarrow</script>
<script type="math/tex">s</script> から始まる無限のパス <script type="math/tex">\pi</script> が存在し，全ての <script type="math/tex">i \ge 0</script> に対して <script type="math/tex">M, s_i \models f</script> となる．</li>
<li>
<script type="math/tex">M, s \models \textbf{E} (f_1 \textbf{U} f_2)</script>
<script type="math/tex">\Leftrightarrow</script>
<script type="math/tex">s</script> から始まる無限のパス <script type="math/tex">\pi</script> が存在し，ある <script type="math/tex">k \ge 0</script> が存在して <script type="math/tex">M, s_k \models f_2</script> かつ全ての <script type="math/tex">0 \le j < k</script> に対して <script type="math/tex">M, s_j \models f_1</script> である．</li>
</ol>
<p>最後に，<script type="math/tex">M</script> に対する関係 <script type="math/tex">\models</script> を CTL* の場合と同様に定義する．</p>
<ol type="1" start="8">
<li>\(M \models f\) \(\Leftrightarrow\) 全ての初期状態 \(s \in S_0\) に対して \(M, s \models f\) である．</li>
</ol>

<p>それ以外の 7 つの CTL 演算子は <script type="math/tex">\textbf{EX}</script>，<script type="math/tex">\textbf{EG}</script>，<script type="math/tex">\textbf{EU}</script> による演算の省略形として解釈できる．
この CTL の意味論が，CTL* の制約文法から得られる意味論と等価であることは理解できるだろう．</p>
<h3 id="actl-actl">全称計算木論理 ACTL* および ACTL</h3>
<p>ACTL* は CTL* の部分論理で，全称パス限定子である <script type="math/tex">\textbf{A}</script> のみが利用できる．
これまでに述べたように，否定を用いれば <script type="math/tex">\textbf{E}</script> を <script type="math/tex">\textbf{A}</script> で表現できてしまうので，ACTL* の式は NNF 形式であるという制約を加える必要がある．</p>
<p>したがって，ACTL* の状態論理式ならびにパス論理式の文法は以下の通りとなる．</p>
<ul>
<li><strong>C1</strong>: <script type="math/tex">p \in AP</script> ならば，<script type="math/tex">p</script> および <script type="math/tex">\neg p</script> は ACTL* 状態論理式である．</li>
<li><strong>C2</strong>: <script type="math/tex">f</script> および <script type="math/tex">g</script> が状態論理式ならば，<script type="math/tex">f \vee g</script>, <script type="math/tex">f \wedge g</script> は ACTL* 状態論理式である．</li>
<li><strong>C3</strong>: <script type="math/tex">f</script> が ACTL* パス論理式ならば，<script type="math/tex">\textbf{A} f</script> は ACTL* 状態論理式である．</li>
</ul>
<p>パス論理式の文法は，以下の 2 つの追加ルールで定められる．</p>
<ul>
<li><strong>C4</strong>: <script type="math/tex">f</script> が ACTL* 状態論理式ならば，<script type="math/tex">f</script> は ACTL* パス論理式でもある．</li>
<li><strong>C5</strong>: <script type="math/tex">f</script> および <script type="math/tex">g</script> が ACTL* パス論理式ならば，<script type="math/tex">f \vee g</script>, <script type="math/tex">f \wedge g</script>, <script type="math/tex">\textbf{X} f</script>, <script type="math/tex">\textbf{F} f</script>, <script type="math/tex">\textbf{G} f</script>, <script type="math/tex">f \textbf{U} g</script>, そして <script type="math/tex">f \textbf{R} g</script> は ACTL* パス論理式である．</li>
</ul>
<p>CTL* と同様に，ACTL* はこのルールに従う状態論理式の集合となる．</p>
<p>
<script type="math/tex">\textbf{A}</script> の代わりに <script type="math/tex">\textbf{E}</script> を用いることで ECTL* 論理が定義される．
ACTL* 式の否定は ECTL* 式と等価となり，ECTL* 式の否定は ACTL* 式となる．
なお，ACTL* と ECTL* のいずれも，時相演算子 <script type="math/tex">\textbf{X}</script>，<script type="math/tex">\textbf{U}</script>，<script type="math/tex">\textbf{R}</script> を用いれば他の演算子を表現することができる．</p>
<div class="admonition note">
<p class="admonition-title">ACTL* の保存性質</p>
<p>ACTL* には非常に有用な保存性質 (preservation property) がある．</p>
<p>具体的には，模倣関係 (simulation relation) にあるクリプキ構造について，ある一方で ACTL* の仕様が満たされるか否かを，それを模倣するクリプキ構造上で仕様を検証することで判定できる．
これにより，あるクリプキ構造からより単純なクリプキ構造に仕様を転送できる．</p>
<p>これに関しては 11 章で詳しく述べる．</p>
</div>
<p>ACTL 論理は，CTL と ACTL* の文法制約を自然に組み合わせたものである．
ACTL の文法は以下の通りとなる．</p>
<ul>
<li><strong>D1</strong>: <script type="math/tex">p \in AP</script> ならば，<script type="math/tex">p</script> および <script type="math/tex">\neg p</script> は ACTL 式である．</li>
<li><strong>D2</strong>: <script type="math/tex">f</script> が CTL 式ならば，<script type="math/tex">\textbf{AX} f</script>，<script type="math/tex">\textbf{AF} f</script>，<script type="math/tex">\textbf{AG} f</script> も ACTL 式である．</li>
<li><strong>D3</strong>: <script type="math/tex">f</script> と <script type="math/tex">g</script> が ACTL 式ならば，<script type="math/tex">f \wedge g</script>，<script type="math/tex">f \vee g</script>，<script type="math/tex">\textbf{A}(f\textbf{U}g)</script>，<script type="math/tex">\textbf{A}(f\textbf{R}g)</script> も ACTL 式である．</li>
</ul>
<p>ACTL 式は <script type="math/tex">\textbf{AX}</script>，<script type="math/tex">\textbf{AU}</script>，そして <script type="math/tex">\textbf{AR}</script> を用いた式へと変換可能である．</p>
<h3 id="ltl">線形時相論理 LTL</h3>
<p>LTL 論理は線形の時相論理である．
LTL は，クリプキ構造の計算木そのものではなく，計算木における単一の計算（すなわちパス）の集合に対して評価される．
LTL 式は <script type="math/tex">\textbf{A}f</script> という形となり，ここで <script type="math/tex">f</script> は CTL* のパス限定子を含まないパス論理式である．
パス論理式が内部にパス限定子をもたないので，部分式として状態論理式となるのは原子命題のみである．</p>
<p>CTL* に対して，パス論理式におけるパス限定子の利用を禁止することで，LTL を得ることができる．
LTL 式は <script type="math/tex">f</script> を LTL パス論理式として <script type="math/tex">\textbf{A}f</script> という形式となる．
LTL パス論理式は以下のように定義される．</p>
<ul>
<li><strong>E1</strong>: <script type="math/tex">p \in AP</script> ならば，<script type="math/tex">p</script> は LTL パス論理式である．</li>
<li><strong>E2</strong>: <script type="math/tex">f</script> が LTL パス論理式ならば，<script type="math/tex">\neg f</script>, <script type="math/tex">\textbf{X} f</script>, <script type="math/tex">\textbf{F} f</script>, <script type="math/tex">\textbf{G} f</script> も LTL パス論理式である．</li>
<li><strong>E3</strong>: <script type="math/tex">f</script> および <script type="math/tex">g</script> が LTL パス論理式ならば，<script type="math/tex">f \vee g</script>, <script type="math/tex">f \wedge g</script>, <script type="math/tex">f \textbf{U} g</script>, そして <script type="math/tex">f \textbf{R} g</script> も LTL パス論理式である．</li>
</ul>
<p>
<script type="math/tex">f \textbf{R} g \equiv \neg (\neg f \textbf{U} \neg g)</script>，<script type="math/tex">\textbf{F} f \equiv true \textbf{U} f</script>，そして <script type="math/tex">\textbf{G} f \equiv \neg \textbf{F} \neg f</script> なので，LTL は <script type="math/tex">\textbf{X}</script> と <script type="math/tex">\textbf{U}</script> 演算子のみで定義できる．</p>
<p>LTL 式の一つだけの全称限定子は省略されることがある．
この場合，LTL パス論理式 <script type="math/tex">f</script> に対する <script type="math/tex">M \models f</script> は <script type="math/tex">M \models \textbf{A}f</script> を意味する．</p>
<h3 id="ctl_2">CTL* の部分論理の関係性</h3>
<p>これまでに説明した 5 つの論理は異なる表現力をもつ．
上述の包含関係の図は，文法と表現力の双方に関するものである．</p>
<p>例を挙げると，LTL 式 <script type="math/tex">\textbf{AFG}p</script> と等価な CTL 式は存在しない．
この式は，全てのパスにおいて，それ以降で <script type="math/tex">p</script> が永久に成り立つような状態が存在することを表している．
同様に，CTL 式 <script type="math/tex">\textbf{AG}(\textbf{EF}p)</script> と等価な LTL 式は存在しない．
この式は，計算木の全てのパス上の状態において，いつか <script type="math/tex">p</script> が成り立つパスが存在することを表している．
これらの論理和である <script type="math/tex">\textbf{A}(\textbf{FG}p) \vee \textbf{AG}(\textbf{EF}p)</script> は CTL* の論理式であるが，CTL と LTL のどちらでも表現できない．</p>
<p>ACTL は CTL の部分論理なので，ACTL と LTL は比較できない．
論理式 <script type="math/tex">\textbf{AF AG}a</script> と <script type="math/tex">\textbf{AF AX}a</script> は ACTL 式であるが，これらの式は LTL では表現できない．
また，ACTL* は LTL より表現力がある論理である．
例として，ACTL* の式である <script type="math/tex">\textbf{AG}p \vee \textbf{AG}q</script> は LTL では表現できない．
最後に，CTL 式 <script type="math/tex">\textbf{AG}(\textbf{EF}p)</script> や <script type="math/tex">\textbf{AG} \neg(\textbf{AF}p)</script> は ACTL では表現できない．
予想外なことに，LTL 式の中には CTL では表現できるが ACTL では表現できないものもある．</p>
<div class="admonition note">
<p class="admonition-title">CTL と LTL では表現できるが ACTL では表現できない特性</p>
<p>Bojańczyk によって「全てのパスが <script type="math/tex">(ab)^*a(ab)^*c^\omega</script> に属する」という言語は，CTL や LTL では表現できるが ACTL では表現できないことが証明されている．
なお，この特性は全てのパスについて満たすべき性質に言及しているにも関わらず，これを表す CTL 式では存在の限定子が用いられるという不思議な結果が得られている．</p>
<p>M. Bojańczyk, "The common fragment of ACTL and LTL," In FOSSACS 2008, LNCS 4692, pp. 172-185, 2008.</p>
</div>
<h2 id="_1">集合原子命題と集合意味論による時相論理</h2>
<p>論理学では，論理式をその式を満たす割り当ての集合と関連付けることが一般的である．
クリプキ構造上で解釈される時相論理の文脈では，その式が真となるクリプキ構造の状態の集合との関連付けに相当する．</p>
<p>したがって，CTL* 状態論理式 <script type="math/tex">f</script> の意味論を，<script type="math/tex">f</script> を満たす状態を用いて表現できる．
クリプキ構造 <script type="math/tex">M</script> が与えられたとき，<script type="math/tex">f</script> と <script type="math/tex">f</script> が真となる状態の集合を以下のように関連付ける．</p>
<p>
<script type="math/tex; mode=display"> [\![ f ]\!]_M = \{ s \in S \mid M, s \models f \} </script>
</p>
<p>文脈から <script type="math/tex">M</script> が明らかな場合は，省略して書くこともある．</p>
<p>CTL* の文法と意味論を，ラベルではなく直接クリプキ構造の状態を参照するよう拡張する．
最終的に，状態の集合は，原子 CTL* 式としてのみ現れることを認めることにする．</p>
<p>
<script type="math/tex">\mathcal{Q} = \{ s_1, \ldots , s_n\} \subseteq S</script> を状態の集合とする．
このとき，<script type="math/tex">\mathcal{Q}</script> は述語としても解釈できる．
つまり，<script type="math/tex">\mathcal{Q}</script> に含まれる状態においてのみ満たされるような特性を表しているといえる．
これを，以下のように文法にも反映する．</p>
<ul>
<li style="list-style: none">
もし \(\{ s_1, \ldots , s_n\} \subseteq S\) ならば，\(\{ s_1, \ldots , s_n\}\) は CTL* 状態論理式であり，<b>集合原子命題</b> (set atomic proposition) と呼ぶ．
</li>
</ul>

<p>Definition 4.2 の意味論も単純に以下のように拡張する．</p>
<ul>
<li style="list-style: none">
1a. \(M, s \models \{ s_1, \ldots , s_n\}\) \(\Leftrightarrow\) \(s \in \{ s_1, \ldots , s_n\}\)
</li>
</ul>

<p>例えば，式 <script type="math/tex">\textbf{EX}\{s, t\}</script> は，1 ステップで状態 <script type="math/tex">s</script> または <script type="math/tex">t</script> に到達可能な状態において真となる．</p>
<h2 id="_2">公平性</h2>
<p><a href="../lec03#_14">第3回</a>で，システムのモデル化における公平性の重要性について述べた．
公平性制約を伴うシステムは，<strong>公平クリプキ構造</strong> (fair Kripke structure) <script type="math/tex">M = (S, S_0, R, L, AP, F)</script>としてモデル化することができる．ここで，<script type="math/tex">S</script>，<script type="math/tex">S_0</script>，<script type="math/tex">R</script>，<script type="math/tex">L</script>，そして<script type="math/tex">AP</script>はこれまでの定義と同様である．
<strong>公平性制約</strong> (fairness constraint) の集合 <script type="math/tex">F</script> は，状態の部分集合 <script type="math/tex">P_i \subseteq S</script> を用いて <script type="math/tex">F = \{P_1, \ldots, P_k\} \subseteq 2^S</script> と定義される．
この <script type="math/tex">F</script> と同様の概念はオートマトンにも存在し，一般化 Büchi 受理条件 (generalized Büchi acceptance condition) と呼ばれている．</p>
<p>
<script type="math/tex">\pi = s_0,s_1,\ldots</script> を <script type="math/tex">M</script> におけるパスとする．パス <script type="math/tex">\pi</script> に対して集合 <script type="math/tex">\text{inf}(\pi)</script> を以下のように定義する．</p>
<p>
<script type="math/tex; mode=display"> \text{inf}(\pi) = \{ s \mid s=s_i \text{ for infinitely many } i \} </script>
</p>
<p>パス <script type="math/tex">\pi</script> において「無限に多くの <script type="math/tex">i</script> に対して (for infinitely many <script type="math/tex">i</script>) <script type="math/tex">s=s_i</script>」となる状態 <script type="math/tex">s</script> とは，<script type="math/tex">\pi</script> 上に無限に現れる状態ということになる．よって <script type="math/tex">\text{inf}(\pi)</script> は，<script type="math/tex">\pi</script> に無限に現れるような全ての状態からなる集合となる．
全ての <script type="math/tex">P \in F</script> に対して <script type="math/tex">\text{inf}(\pi) \cap P \neq \emptyset</script> であるとき，かつそのときのみ <script type="math/tex">\pi</script> は<strong>公平</strong> (fair) であるという．</p>
<p><a href="#_1">集合原子命題を用いた CTL*</a> においては，パスの公平性を以下の式を用いて直接表現することができる．</p>
<p>
<script type="math/tex; mode=display"> \text{fpath} :\equiv \bigwedge_{P \in F}\bigvee_{s \in P} \textbf{GF}\{s\} </script>
</p>
<p>この式は，それぞれの <script type="math/tex">P</script> が少なくとも 1 つはパスに無限にしばしば現れる状態を含まなければならない，ということを表している．
したがって，<script type="math/tex">\textbf{E}\varphi</script> あるいは <script type="math/tex">\textbf{A}\varphi</script> という形式の仕様は，論理式 <script type="math/tex">\text{fpath}</script> を用いてそれぞれ
<script type="math/tex">\textbf{E}(\text{fpath} \wedge\varphi)</script> あるいは <script type="math/tex">\textbf{A}(\text{fpath} \rightarrow\varphi)</script>
と書くことで，公平性を適用できる．
1つ目の式 <script type="math/tex">\textbf{E}(\text{fpath} \wedge\varphi)</script> は，公平でかつ <script type="math/tex">\varphi</script> を満たすパスが存在することを表現している．
2つ目の式 <script type="math/tex">\textbf{A}(\text{fpath} \rightarrow\varphi)</script> は，全てのパスについて，公平であれば必ず <script type="math/tex">\varphi</script> を満たすことを表現している．</p>
<p>ここで，<script type="math/tex">\textbf{GF}</script> という形の式は CTL では表現できないため，上述の公平性制約は CTL では表現できない．
そのため，CTL で公平性を扱うためには，その意味論を少し修正する必要がある．
新しい意味論を<strong>公平意味論</strong> (fair semantics) と呼ぶことにする．
一般性のため，CTL* の意味論をもとに公平意味論を定義する．
<script type="math/tex">M, s \models_{F} f</script> と書くことで，公平クリプキ構造の状態 <script type="math/tex">s</script> において状態論理式 <script type="math/tex">f</script> が真となることを表す．
同様に，<script type="math/tex">M, \pi \models_{F} g</script> と書くことで，公平クリプキ構造のパス <script type="math/tex">\pi</script> においてパス論理式 <script type="math/tex">f</script> が真となることを表す．
定義 4.2 の節 5 と 6 のみが以下のように変更される．</p>
<ol type="1" start="5">
<li>\(M, s \models_{F} \textbf{E} g_1\) \(\Leftrightarrow\) \(s\) から始まる公平なパス\(\pi\) が存在して， \(M, \pi \models_{F} g_1\) を満たす．</li>
<li>\(M, s \models_{F} \textbf{A} g_1\) \(\Leftrightarrow\) \(s\) から始まるすべての公平なパス \(\pi\) が，\(M, \pi \models_{F} g_1\) を満たす．</li>
</ol>

<p>式を公平性に基づいて解釈することを明示するため，<script type="math/tex">\textbf{E}</script> および <script type="math/tex">\textbf{A}</script> の代わりに <script type="math/tex">\textbf{E}_{\text{f}}</script> および <script type="math/tex">\textbf{A}_{\text{f}}</script> を用いる場合がある．</p>
<p>節 6 により，仮に状態 <script type="math/tex">s</script> から始まる公平なパスが存在しなければ，あらゆる式 <script type="math/tex">\varphi</script> に対して（意味は無いが） <script type="math/tex">M, s \models \textbf{A}_{\text{f }} \varphi</script> となる．
また，公平性を考慮しない意味論では <script type="math/tex">p \in AP</script> に対して 3 つの式 <script type="math/tex">p</script>，<script type="math/tex">\textbf{E}p</script> および <script type="math/tex">\textbf{A}p</script> が全て等価であることとは対照的に，<script type="math/tex">p</script> は <script type="math/tex">\textbf{E}_{\text{f }}p</script> と <script type="math/tex">\textbf{A}_{\text{f }}p</script> のいずれとも等価とはならない．
特に，<script type="math/tex">p \in L(s)</script> であるが <script type="math/tex">s</script> から始まる公平なパスが存在しなければ <script type="math/tex">M, s \models p \wedge \neg \textbf{E}_{\text{f }}p</script> となるし，<script type="math/tex">p \notin L(s)</script> であり <script type="math/tex">s</script> から始まる公平なパスが存在しなければ <script type="math/tex">M, s \models \neg p \wedge \textbf{A}_{\text{f }}p</script> となる．
これは，<script type="math/tex">p \wedge \textbf{E}p</script> および <script type="math/tex">\neg p \wedge \textbf{A} p</script> が本質的に偽となる従来の意味論とは対照的である．</p>
<p>第3回の講義では，システムのモデル化における公平性の有用性を示す例を紹介した．
以降では，モデル検査アルゴリズムにどのように公平性を取り入れるかについて示す．</p>
<p>公平性制約をもたない構造を公平性制約をもつ構造として表すことが便利な場合もある．
その際には，計算として考慮されるパスの集合が保持される．
これは，<script type="math/tex">F = \{S\}</script> とすることで達成できる．</p>
<h2 id="_3">反例</h2>
<p>反例の生成はモデル検査の中心的な機能であり，モデル検査が定理証明や抽象的解釈といった他の検証アプローチと異なる部分である．
最も単純な形として，反例は仕様に違反することを示す系列である．
したがって，反例はシステムを開発した技術者に対する貴重なフィードバックとなる．</p>
<p>理想的には，仕様 <script type="math/tex">f</script> がシステムのモデル <script type="math/tex">M</script> において違反する（すなわち  <script type="math/tex">M \nvDash f</script> となる）とき，反例 <script type="math/tex">C</script> はユーザが問題を体系的に分析・診断できるように <script type="math/tex">M</script> の動作を分かりやすく説明したものとなる．
反例が単純であることは，人間が分析する上で非常に重要なことである．
仮に単純さが重要でないのならば，（全く役には立たないが）<script type="math/tex">M</script> 自身が反例となる．</p>
<p>もう一つ必須となる要件は，<script type="math/tex">C</script> は有限の表現とし，検査・分析できるようにすることである．
現実的に有用となる反例の特徴を捉えるため，ここでは議論を<strong>有限クリプキ構造</strong>，すなわち状態集合が有限となるクリプキ構造に限定する．</p>
<p>反例は人間の読者にとって重要であるだけでなく，アルゴリズムにも応用できる．
第 13 章において，モデル検査器によって得られた反例をアルゴリズム的に解析し，さらなる検証プロセスの指針とする counterexample-guided abstraction refinement (CEGAR) を紹介する．
ここでは，反例の構造について詳しく説明する．</p>
<p>単純な仕様 <script type="math/tex">\textbf{AX}p</script> に対する反例は，初期状態から1ステップで <script type="math/tex">p</script> の違反を導くパスとなる．
したがって，<script type="math/tex">\textbf{AX}p</script> の反例は，仕様の否定である <script type="math/tex">\textbf{EX}\neg p</script> の証拠となる．</p>
<p>最も単純でかつ自明でない例として，<script type="math/tex">p</script> がシステムのモデル <script type="math/tex">M</script> の不変式であることを表す仕様 <script type="math/tex">\textbf{AG}p</script> の反例を考えてみよう．
<script type="math/tex">\textbf{AG}p</script> の反例 <script type="math/tex">C</script> は，初期状態から始まり，<script type="math/tex">p</script> に違反する状態（これを <script type="math/tex">s</script> とすると <script type="math/tex">s \models \neg p</script>）で終わる有限パス（プログラムのトレース）である．
上述の通り，この反例は仕様の否定 <script type="math/tex">\textbf{EF} \neg p</script> の証拠である．</p>
<p>もう少し複雑な仕様 <script type="math/tex">\textbf{AF}p</script> を考えよう．
<script type="math/tex">\textbf{AF}p</script> の反例は，その全ての状態が <script type="math/tex">\neg p</script> を満たすような無限パスである．
しかしながら，有限クリプキ構造では，有限パス <script type="math/tex">\pi_0</script> および <script type="math/tex">\pi_1</script> とその無限の繰り返しによる
<script type="math/tex">\pi = \pi_0(\pi_1)^\omega = \pi_0,\pi_1,\pi_1,\ldots</script>
という形の反例 <script type="math/tex">\pi</script> が常に存在するということが示されている．
このような形のパスは<strong>ラッソ</strong>（投げ縄）と呼ばれる．
以下の図は LTL 式 <script type="math/tex">\textbf{AG}p</script> および <script type="math/tex">\textbf{AF}p</script> に対する反例の形状を示している．</p>
<p><center>
<img src="../img/lec05-fig2.png" width="600">
</center></p>
<p>反復補題 (pumping lemma) と同様の簡単な議論をもとに，ラッソ型の反例が存在することを証明する．
パス <script type="math/tex">\pi = s_0,s_1,\ldots</script> を <script type="math/tex">\textbf{AF}p</script> の反例とする．
すなわち，全ての <script type="math/tex">s_i</script> に対して <script type="math/tex">M, s_i \models \neg p</script> となる．
<script type="math/tex">M</script> は有限個数の状態しかもたないので，<script type="math/tex">s_n = s_m</script> となるような 2 つの添字 <script type="math/tex">1 \le n < m</script> が必ず存在する．
このとき，<script type="math/tex">\pi_0 = s_0, \ldots , s_{n-1}</script> と <script type="math/tex">\pi_1 = s_n, \ldots , s_{m-1}</script> を選ぶことでラッソ型の反例を構築することが可能である．
元々の反例は，このラッソ型の反例に含まれていない状態を含んでいてもよい．</p>
<p>上記の議論を拡張して，全ての LTL 式がラッソ型の反例をもつことを証明することもできる．
しかし，一般的には，公平性制約も議論に含まれるべきである．
この問題に対する完全な議論は，オートマトンの文脈で第 7 章 7.5 節において示されており，そこでは Büchi オートマトンの空虚性 (emptiness) を検査するアルゴリズムについて議論がなされている．</p>
<p>文献 [137] や [440] で示されているように，ACTL や CTL に対してはさらに詳細な反例が与えられる．</p>
<h2 id="_4">安全性と活性</h2>
<p>安全性と活性の概念については幅広い議論がなされてきた．
直感的には，安全性は悪いことが決して起こらないことを保証するのに対して，活性は良いことがいつか起こることを保証するものである．
最も典型的な安全性は <script type="math/tex">\textbf{AG}p</script> である．
典型的な活性の例としては，<script type="math/tex">\textbf{AF}p</script> や <script type="math/tex">\textbf{A}(p \textbf{U} q)</script> である．
これらの例はさらに複雑にすることができる．</p>
<p>反例を用いれば，安全性と活性を自然に区別することができる．
安全性とは，有限かつループのない反例，すなわち有限パスによって反証できる特性である．
対して，有限状態構造を扱うことから，活性は一般的にラッソ（投げ縄）型の反例を要求する．</p>
<p>安全性と活性の概念は文献 [411] で初めて導入され，[333] や [16] で洗練されてきた．
文献 [136] のPiterman による時相論理の節では，これらの概念に関する形式的な定義が与えられている．</p>
<h2 id="_5">演習問題</h2>
<div class="admonition note">
<p class="admonition-title">問題 4.1 (Alan Hu による CTL 式の等価性)</p>
<p>CTL 式の組について，与えられたクリプキ構造において，まったく同じ状態集合において真となるとき，それらは等価 (equivalent) という．
以下の CTL 式の組が等価であるかどうか確認せよ．
もしそうであれば，証明を示せ．
もし等価でなければ，一方の式が真となり，もう一方が偽となるようなクリプキ構造と状態の例を示せ．</p>
<p><ol>
<li><script type="math/tex">\textbf{EF}p \wedge \textbf{EG}q</script> と <script type="math/tex">\textbf{EF}(p \wedge \textbf{EG}q)</script></li>
<li><script type="math/tex">\textbf{AF}p \wedge \textbf{AG}q</script> と <script type="math/tex">\textbf{AF}(p \wedge \textbf{AG}q)</script></li>
<li><script type="math/tex">\textbf{AF}p \wedge \textbf{AG}q</script> と <script type="math/tex">\textbf{AG}(\textbf{AF}p \wedge q)</script></li>
<li><script type="math/tex">\textbf{AFAG}p \wedge \textbf{AFAG}q</script> と <script type="math/tex">\textbf{AF}(\textbf{AG}p \wedge \textbf{AG}q)</script></li>
<li><script type="math/tex">\textbf{E}(p \textbf{U} q) \wedge \textbf{E}(q \textbf{U} r)</script> と <script type="math/tex">\textbf{E}(p \textbf{U} r)</script></li>
<li><script type="math/tex">\textbf{A}(p \textbf{U} q) \wedge \textbf{A}(q \textbf{U} r)</script> と <script type="math/tex">\textbf{A}(p \textbf{U} r)</script></li>
</ol></p>
</div>
<div class="admonition note">
<p class="admonition-title">問題 4.2 (LTL 演算子の拡張)</p>
<p>以下の LTL 式に関する特性を証明せよ．</p>
<p><center>
<script type="math/tex">f_1 \textbf{U} f_2 \Leftrightarrow f_2 \vee (f_1 \wedge \textbf{X}(f_1 \textbf{U} f_2)) </script>
</p>
<p>
<script type="math/tex">f_1 \textbf{R} f_2 \Leftrightarrow f_2 \vee (f_1 \wedge \textbf{X}(f_1 \textbf{R} f_2)) </script>
</center></p>
</div>
<div class="admonition note">
<p class="admonition-title">問題 4.4 (CTL 演算子の表現力)</p>
<p>CTL 演算子のすべてが，<script type="math/tex">\textbf{AX}</script>，<script type="math/tex">\textbf{AU}</script>，そして <script type="math/tex">\textbf{AR}</script> の 3 つの CTL 演算子に，否定を含むブール演算子を組み合わせることで表現できることを示せ．</p>
</div>
<div class="admonition note">
<p class="admonition-title">問題 4.5 (CTL の意味論)</p>
<p>直接定義された CTL の意味論が，CTL* の部分論理としての CTL の意味論と等価であることを証明せよ．
つまり，すべての CTL 式 <script type="math/tex">f</script> とすべての <script type="math/tex">M</script> および <script type="math/tex">s</script> に対して，<script type="math/tex">M</script> および <script type="math/tex">s</script> における <script type="math/tex">f</script> の値が 2 つの意味論のもとで同一であることを示せ．</p>
</div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../lec04/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                第4回
              </div>
            </div>
          </a>
        
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.7e0ee788.min.js"></script>
      <script src="../assets/javascripts/bundle.b3a72adc.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS_CHTML"></script>
      
    
  </body>
</html>