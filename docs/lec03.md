# 第3回 ハードウェア・ソフトウェアのモデル化

この回では，教科書の第3章 "Modeling Systems" の後半（3.5 Modeling Digital Circuit 〜 3.7 Fairness）について説明します．
前回の講義で説明した一階論理を用いてのモデル化を，実際のハードウェア・ソフトウェアシステムにどのように適用するかについて，簡単な例題を用いて説明します．
また，並行システムをモデル化する際に考慮すべき問題である公平性とその扱い方についても紹介します．

!!! 概要
    - デジタル回路のモデル化
    - プログラムのモデル化
    - 逐次プロセスのモデル化
    - 並行プロセスのモデル化
    - 公平性


## デジタル回路のモデル化
### 状態保持要素

まず，デジタル回路をどのようにして論理式として記述するかについて説明する．
デジタル回路の振る舞いを考える上では，実際にデータを格納するために使用されるのは回路の特定の要素のみである．
これを**状態保持要素** (state-holding elements) と呼ぶ．
同期回路の場合は，外部からの入力と，回路内のすべてのレジスタの出力が状態保持要素となる．
一方で非同期回路の場合は，回路内のすべての配線が状態保持要素とみなされる．

状態保持要素の集合を $V$ で表すことにする．
簡単のために，状態保持要素はそれぞれ 0 か 1 の値のみをもつと仮定すると，$V$ の各要素はブール変数で表すことができる．
状態は，各変数に 0 または 1 を割り当てた付値として記述できる．
そして付値が与えられると，まさにその付値に対して真であるブール式を書くことができる．

例えば，$V = \{v_1, v_2\}$ と付値 $\langle v_1 \mapsto 1, v_2 \mapsto 0 \rangle $ が与えられたとすると，この付値についてのみ真となるブール式 $v_1 \wedge \neg v_2$ が導出される．

前回の講義で説明したように，論理式はその式を真とする**全ての**付値の集合を表す，という慣例を採用している．
このように，回路の振る舞いを記述するには一階論理の表現力を全て用いる必要はなく，ブール式で十分である．
ブール式 $ \mathcal{S}_0(V)$ と $\mathcal{R}(V, V')$ は，それぞれ回路の初期状態の集合と遷移関係を表す．

### 同期回路

同期回路の動作は，**ステップ**の列として構成される．
各ステップでは，回路への入力が変化した後，安定状態に到達することが認められる．
その後にクロックパルスが発生して，状態保持要素のもつ値が変化する．

簡単な例を用いて，同期回路の遷移関係を論理式として表すための方法を説明する．
ここでは，モジュロ 8 カウンタを用いる．
モジュロ 8 カウンタは 3 つのレジスタをもち，そのレジスタの出力からなる 3 ビットの数 $v_2v_1v_0$ が $000 \rightarrow 001 \rightarrow 010 \rightarrow \cdots \rightarrow 111 \rightarrow 000 $ と 0 から 7 までの値の変化を繰り返すカウンタである．

モジュロ 8 カウンタは入力信号がないので，状態保持要素は 3 つのレジスタの出力 $v_2, v_1, v_0$ となる．
$V = \{v_0, v_1, v_2\}$ をこの回路の状態変数の集合とし，状態変数のコピーの集合を $V' = \{v_0', v_1', v_2'\}$ とする．

モジュロ 8 カウンタの遷移は，回路の構成から得られるそれぞれの状態保持要素の変化として，以下で与えられる．
\begin{eqnarray*}
v_0' & = & \neg v_0 \\
v_1' & = & v_0 \oplus v_1 \\
v_2' & = & (v_0 \wedge v_1) \oplus v_2
\end{eqnarray*}
ここで，$\oplus$ は排他的論理和を表している．

上記の等式を用いて，以下の関係を定義することができる．
\begin{eqnarray*}
\mathcal{R}_0(V, V') & \equiv & (v_0' \Leftrightarrow \neg v_0)\\
\mathcal{R}_1(V, V') & \equiv & (v_1' \Leftrightarrow v_0 \oplus v_1)\\
\mathcal{R}_2(V, V') & \equiv & (v_2' \Leftrightarrow (v_0 \wedge v_1) \oplus v_2)
\end{eqnarray*}
これらの関係は，それぞれの $v_i'$ が正しく遷移する際に満たすべき制約を記述している．

同期回路における値の変化は同時に発生するため，これらの制約の**論理積**として，遷移関係の論理式を得ることができる．
\[ \mathcal{R}(V, V') = \mathcal{R}_0(V, V') \wedge \mathcal{R}_1(V, V') \wedge \mathcal{R}_2(V, V') \]

一般に，$n$ 個の状態保持要素をもつ同期回路では，$ V = \{v_0, \ldots , v_{n-1}\}$ および $V' = \{v_0', \ldots , v_{n-1}'\}$ となる．

モジュロ 8 カウンタの例と同様に，レジスタに対応するそれぞれの状態変数 $v_i'$ について，以下のブール関数 $f_i$ が存在する．
\[ v_i' = f_i(V) \]

そして，これらの等式を用いて，以下の関係を定義できる．
\[ \mathcal{R}_i(V, V') \equiv (v_i' \Leftrightarrow f_i(V)) \]

なお，回路への外部入力に対応する変数については，このような関数を定義する必要はない．
こういった変数は，以下のように定義することで未制約のままにできる．
\[ \mathcal{R}_i(V, V') \equiv true \]

そして，遷移関係の論理式もモジュロ 8 カウンタの場合と同様に，これらの制約の論理積として以下のように得ることができる．
\[ \mathcal{R}(V, V') \equiv \mathcal{R}_0(V, V') \wedge \ldots \wedge \mathcal{R}_{n-1}(V, V'). \]
このように，同期回路の遷移関係は，個別の状態保持要素の遷移関係の論理積として表現することができる．

### 非同期回路
非同期回路については，時間を考慮しない非常に単純なモデルについてのみ説明する．
非同期回路の遷移関係は，**論理和**として表現するのが最も自然である．

遷移関係がどのようにして得られるかの説明を簡単にするため，回路のすべての構成要素はただ 1 つの出力をもち，内部状態変数をもたないと仮定する．
この場合，同期回路と同じようにそれぞれの構成要素を関数 $f_i(V)$ で記述することができる．
現状態の変数 $V$ に値が与えられると，構成要素は $f_i(V)$ で指定された値で出力を行う．
この手法は，簡単に複数の出力をもつ構成要素を扱うよう拡張できる．

構成要素の値は非常に高速に変化するため，2 つの構成要素が同時に変化するだろうとは考えにくい．
この理由から，一度にただ一つの構成要素のみが変化する，**交互実行セマンティクス** (interleaving semantics) を用いるのが慣例となっている．

その結果として，以下のように論理和の形で遷移関係の論理式を得ることができる．
\[ \mathcal{R}(V, V') \equiv \mathcal{R}_0(V, V') \vee \ldots \vee \mathcal{R}_{n-1}(V, V') \]
ここで，
\[ \mathcal{R}_i(V, V') \equiv (v_i' \Leftrightarrow f_i(V)) \wedge \bigwedge_{j \neq i}(v_j' \Leftrightarrow v_j) \]
であり，同時に 2 つの構成要素が変化しないよう制約が設けられている．

注意すべきは，この論理式はある構成要素のみが（他の構成要素が決してステップを実行することなく）繰り返し変化することを許容しているということである．
実際には，こういったことは非常に考えにくい．
このような動作を認めない，**公平性** (fairness) に関する追加の制約をもつモデルについて議論することが可能である．
この話題については，4 章でさらに議論を行う．


#### Example 3.3
同期および非同期のモデルの違いを説明するため，以下の例を考えよう．
$V = \{v_0, v_1\}$ とし，$v_0' = v_0 \oplus v_1$，$v_1' = v_0 \oplus v_1$ とする．
$s$ を $v_0 = 1 \wedge v_1 = 1$ となる状態とする．
同期モデルに従うと，両方の割当は同時に実行されるため，$s$ の唯一の後続状態は $v_0 = 0 \wedge v_1 = 0$ となる状態である．
非同期モデルに従うと，$s$ は以下の 2 つの後続状態をもつ．

- $v_0 = 0 \wedge v_1 = 1$ ($v_0$ への割当を最初に実行した場合)
- $v_0 = 1 \wedge v_1 = 0$ ($v_1$ への割当を最初に実行した場合)


## プログラムのモデル化
これから，ソフトウェアのモデル化について説明する．
まず，逐次プログラムの基本的な場合について議論し，次に，非同期の同時実行セマンティクスをもつ並列プログラムの場合へと拡張を行う．

### 逐次プロセスのモデル化
我々が使用するアプローチは，Manna と Pnueli によるアプローチと類似したものである．
ここでは，理想的なプログラミング言語のモデルについて議論する．

プログラムは，連続した文から構成される．
ここでは，逐次プログラム $P$ のテキストを，プログラムの遷移の集合を表す一階の論理式 $\mathcal{R}$ に変換するための手続き $\mathcal{C}$ について示す．
一般性を損なうことなく，それぞれの文には一意な**開始点** (entry point) と一意な**終了点** (exit point) があると仮定できる．
プログラム中のそれぞれの文に開始点と終了点が一意にラベル付けされていれば，変換手続きは大幅に単純化される．
そこで，ラベル付けされていないプログラム $P$ が与えられたとき，ラベル付けされたプログラム $P^{\mathcal{L}}$ を得られるようなラベル付け変換を定義する．
このラベルを**プログラム位置** (program locations) と呼ぶ．

以下で定義するラベル付け変換は，$P$ 自身を除いた $P$ の各文の開始点に，1 つの位置ラベルを添付する．
異なる位置に同じラベルが 2 度付けられることはない．
逐次プログラムでは，ある文の終了点は次の文の開始点と同一なので，それぞれの開始点にラベルを付ければ十分である．
そして最後に，$P$ 自身の開始点と終了点にラベルを付ければ，プログラムのすべての文の開始点と終了点への一意なラベル付けを行ったことになる．

### プログラムへのラベル付け

ここでは特定のプログラミング言語の詳細を抽象化することを目的としているため，いくつかの共通の形式の文に対するラベル付け変換を定義する．
この定義を他の形式の文へと拡張することは，難しいことではない．

文 $P$ が与えられたとき，**ラベル付き文** (labeled statement) $P^{\mathcal{L}}$ は以下のように定義される．

- $P$ が複合文でない（例えば $P$ が $x := e$, $\textbf{skip}$, $\textbf{wait}$, $\textbf{lock}$, $\textbf{unlock}$,	など）ならば，

    $P^{\mathcal{L}} = P$ とする．

- $P= P_1; P_2$ ならば，

    $l_1$ を新たなラベルとして $P^{\mathcal{L}} = P_1^{\mathcal{L}}; l_1 : P_2^{\mathcal{L}} $ とする．

- $P =$ $\textbf{if}$ $b$ $\textbf{then}$ $P_1$ $\textbf{else}$ $P_2$ $\textbf{end if}$ ならば，

    $l_1$ および $l_2$ を新たなラベルとして $P^{\mathcal{L}} =$ $\textbf{if}$ $b$ $\textbf{then}$ $l_1 : P_1^{\mathcal{L}}$ $\textbf{else}$ $l_2 : P_2^{\mathcal{L}}$ $\textbf{end if}$ とする．

- $P =$ $\textbf{while}$ $b$ $\textbf{do}$ $P_1$ $\textbf{end while}$ ならば，

    $l_1$ を新たなラベルとして $P^{\mathcal{L}} =$ $\textbf{while}$ $b$ $\textbf{do}$ $l_1: P_1^{\mathcal{L}}$	$\textbf{end while}$ とする．


以降では，$P$ がラベル付き文であり，$P$ の開始点と終了点がそれぞれ $m$ と $m'$ でラベル付けされていると仮定する．

### プログラムカウンタ

ここで，$pc$ を**プログラムカウンタ** (program counter) と呼ばれる，プログラム位置の集合と，プログラムが**中断** (suspend) されていることを示す追加の値 $\textbf{susp}$ を定義域とする特別な変数とする．
この値 $\textbf{susp}$ は並列プログラムを考慮する場合に必要となる．
この場合，$pc = \textbf{susp}$ はプログラムが現在アクティブではないことを示す．

### ラベル付きプログラムから論理式への変換手続き

$V$ をプログラム変数の集合とする．
$V'$ を $v \in V$ それぞれに対するプライム付き変数 $v'$ の集合とし，$pc'$ を $pc$ に対するプライム付き変数とする．
ハードウェアのモデル化と同様に，プライム無しの変数は遷移前の変数の値を参照しており，プライム付き変数は遷移後の値を参照している．

通常，それぞれの遷移は少数のプログラム変数しか変更しないため，式
\[ \bigwedge_{y \in Y}(y' = y) \]
の省略形として $same(Y)$ を用いることにする．

まず，プログラム $P$ の初期状態の集合を表す式を与える．
$P$ の変数の初期値についてある条件 $pre(V)$ が与えられたとき，
\[ \mathcal{S}_0(V, pc) \equiv pre(V) \wedge pc= m \]
となる．

変換手続き $\mathcal{C}$ は，開始ラベル $l$，ラベル付き文 $P$，そして終了ラベル $l'$ という 3 つのパラメータに依存する．
この手続きは，プログラム言語におけるそれぞれの文に応じたルールによって再帰的に定義される．
$\mathcal{C}(l, P, l')$ は，$P$ における遷移の集合を，集合内のすべての遷移の論理和として表す．
論理和で結合されたそれぞれの式に対して，プログラムカウンタの値に対する条件によって，遷移が選択され実行される．

- **代入**

    $\mathcal{C}(l, v:=e, l') \equiv pc=l \wedge pc' = l' \wedge v' = e \wedge same(V\setminus \{v\})$

- **Skip**

    $\mathcal{C}(l, skip, l') \equiv pc=l \wedge pc' = l' \wedge same(V)$

- **逐次処理**

    $\mathcal{C}(l, P_1; l'' :P_2, 1) \equiv \mathcal{C}(l, P_1, l'') \vee \mathcal{C}(l'', P_2, l')$

    したがって，$P_1; l'' :P_2$ の遷移に対する式は，$P_1$ の遷移の式と $P_2$ の遷移の式の論理和となる．
	中間ラベル $l''$ により，文 $P_2$ が実行されるのは $l''$ に到達した後，すなわち，文 $P_1$ の後のみであることが保証される．

- **if**

    $\mathcal{C}(l,$ $\textbf{if}$ $b$ $\textbf{then}$ $l_1 : P$ $\textbf{else}$ $l_2 : P_2$ $\textbf{end if}$ $, l')$ は以下の 4 つの式の論理和となる:
		\begin{align*}
			           & (pc = l \wedge pc' = l_1 \wedge b = true \wedge same(V))\\
			\vee \quad & (pc = l \wedge pc' = l_2 \wedge b = false \wedge same(V))\\
			\vee \quad & \mathcal{C}(l_1, P_1, l')\\
			\vee \quad & \mathcal{C}(l_2, P_2, l')
		\end{align*}

    1 つめの式は条件 $b$ が真の場合に対応する．この場合，文 $P_1$ が次に実行される．
  2 つめの式は条件 $b$ が偽の場合に対応する．この場合は，文 $P_2$ が次に実行される．
	いずれの式も，プログラムカウンタの変更のみを伴う遷移を表している．
	3 つめと 4 つめの式は，それぞれ $P_1$ と $P_2$ の遷移に対する式である．
	$l'$ は $P_1$ と $P_2$ の両方に対する終了点であることに注意してほしい．
	$\textbf{if}$ 文に対する変換は，簡単に（例えばこの式から $b$ を削除するなどして）複数の選択肢の非決定的選択を扱うよう拡張できる．

- **While**

    $\mathcal{C}(l,$ $\textbf{while}$ $b$ $\textbf{do}$ $l_1: P_1^{\mathcal{L}}, l')$ は以下の 3 つの式の論理和となる:
		\begin{align*}
			           & (pc = l \wedge pc' = l_1 \wedge b \wedge same(V))\\
			\vee \quad & (pc = l \wedge pc' = l' \wedge \neg b \wedge same(V))\\
			\vee \quad & \mathcal{C}(l_1, P_1, l)
		\end{align*}

    1 つめの式は条件 $b$ が真の場合に対応する．この場合，文 $P_1$ が次に実行される．
	2 つめの式は条件 $b$ が偽となり，$\textbf{while}$ 文の実行が終了する場合に対応する．
	3 つめの式は $P_1$ の遷移の集合に対する式である．
	$P_1$ の終了点は while 文の開始点と一致することに注意してほしい．
	したがって，$P_1$ が終了すると，while 文の実行が再開される．


### 並行プロセスのモデル化

並行システムは，同時に実行するコンポーネントの集合から構成される．
コンポーネントは互いに通信する手段を持っているのが普通である．
システムによって実行形式と通信形式は異なる場合がある．
ここでは以下の 2 つの実行形式を考える．
**非同期実行**（あるいは**交互実行**）は，一つのコンポーネントだけが一度にステップを行う．
**同期実行**は，全てのコンポーネントが同時にステップを行う．
また，異なる通信形式を区別することもできる．
例えば，コンポーネントは**共有変数**の値の変更だったり，キューやハンドシェイクプロトコルによる**メッセージ交換**を行ったりすることで通信が可能である．
ここでは形式の違いには注目せず，共有変数を用いた通信についてのみ説明する．

**並行プログラム** (concurrent program) は，並列に実行可能なプロセスの集合から構成される．
**プロセス**は，これまでにも述べた逐次実行される文である．
ここでは，つねに 1 つのプロセスだけが遷移できる非同期プログラムを考える．

まず，いくつかの用語を導入する．
$V_i$ は，プロセス $P_i$ によって変更可能な変数の集合である．
これらの集合は互いに素で無くてもよい．
これまでと同様に，$V$ はすべてのプログラム変数からなる集合である．
プロセス $p_i$ のプログラムカウンタは $pc_i$ であり，$pc$ はすべてのプログラムカウンタからなる集合である．

並行プログラム $P$ は，以下のような形となる．
\[ \textbf{cobegin } P_1 || P_2 || \ldots || P_n \textbf{ coend}\]
ここで，$P_1, \ldots , P_n$ はプロセスである．

逐次プログラム内の文として並行プログラムが現れることができるよう，逐次プログラムのラベル付け変換を拡張する．
この変換では，各プロセスの開始点と終了点にラベルを付ける．
逐次プログラムの終了点とは異なり，並行プロセスの終了点は開始点と同一ではないため，プロセスの終了点に明示的にラベルを付ける必要がある．
これまでと同様に，ラベルが同一になることはなく，$P$ の開始点と終了点にそれぞれ $m$ と $m'$ のラベルが付けられていることを仮定する．

- $P =$ $\textbf{cobegin}$ $P_1 \Vert P_2 \Vert \ldots \Vert P_n$ $\textbf{coend}$ ならば，

	$P^{\mathcal{L}} =$ $\textbf{cobegin}$ $l_1 : P_1^{\mathcal{L}} l_1' \Vert l_2 : P_2^{\mathcal{L}} l_2' \Vert \ldots \Vert l_n : P_n^{\mathcal{L}}$ $\textbf{coend}$ とする．

並行プログラム $P$ の初期状態を記述する式は以下のようになる．
\[ \mathcal{S}_0(V, PC) \equiv pre(V) \wedge pc=m \wedge \bigwedge_{i=1}^{n} (pc_i = \textbf{susp}), \]
ここで，$pc_i = \textbf{susp}$ は、プロセス $P_i$ がまだ起動しておらず，現在の状態から実行できないことを示している．

### 並行プログラムから論理式への変換手続き

変換手続き $\mathcal{C}$ は，以下のように並行プログラムに拡張される．

$\mathcal{C}(l, $ $\textbf{cobegin}$ $l_1 : P_1^{\mathcal{L}} l_1' \Vert \ldots \Vert l_n : P_n^{\mathcal{L}}, l')$ の結果は，以下の 3 つの式の論理和となる．

\begin{align*}
           & (pc = l \wedge pc_1' = l_1 \wedge \ldots \wedge pc_n' = l_n \wedge pc' = \textbf{susp}) \\
\vee \quad & (pc = \textbf{susp} \wedge pc_1 = l_1' \wedge \ldots \wedge pc_n = l_n' \wedge pc' = l' \wedge \bigwedge_{i=1}^n(pc_i' = \textbf{susp})) \\
\vee \quad & \bigvee_{i=1}^{n}(\mathcal{C}(l_i, P_i, l_i') \wedge same(V\setminus V_i) \wedge same(PC\setminus \{ pc_i\}))
\end{align*}

1 つめの式は，並行プロセスの初期化を表している．
$\textbf{cobegin}$ 文の開始点から，個々のサブプロセスの開始点へと遷移が行われる．
同時に，サブプロセスを生成するプログラムは中断される．

2 つめの式は，並行プログラムの終了を表している．
サブプロセスの終了点から，$\textbf{cobegin}$ 文の終了点へと遷移が行われる．
この遷移は，すべてのプロセスが終了した場合にのみ実行される．

3 つめの式は，並行プロセスの実行を表している．
我々は交互実行セマンティクスを用いており，つねにただ一つのプロセスだけが遷移を行う．
プロセス $P_i$ の遷移関係の式は，以下の式との論理積となる．
\[ same (V \setminus V_i) \wedge same(PC \setminus \{ pc_i \})). \]

これは，プロセス $P_i$ 内の遷移が $V_i$ 内の変数のみを変更できることを保証している．
また，ただひとつのプロセスのみが遷移を行うことができることも保証される．
遷移を行うプロセスは，非決定的に選択される．

### 共有変数

$V_i$ は，プロセス $P_i$ で変更される可能性のある変数の集合である．
$V_i$ の集合がオーバーラップする並行プログラムを，**共有変数** (shared variable) プログラムと呼ぶ．
変換手続き $\mathcal{C}$ を，よく使われる**プロセス同期化**文に拡張する方法を示す．
こういった文は，共有変数への排他アクセスをプロセスに提供するためによく必要とされる．
これらの文は原子的であり，文に応じてラベル付け変換が行われる．
文がプロセス $P_i$ に属していると仮定する．

- **Wait**

    我々の主な関心事は有限状態プログラムにあるので，この文を**ビジーウェイト** (busy waiting) を用いてどのように実装するかについてのみ示す．
    特に，プロセスキューのような複雑なデータ構造を必要とする実装は考慮しない．
    文 $\textbf{wait}(b)$ は，ブール変数 $b$ の値を，$b$ が真であると判断するまで繰り返し確認する．
    $b$が真になると，次のプログラムポイントに遷移する．
    $\mathcal{C}(l, \textbf{wait}(b), l')$ は以下の 2 つの式の論理和となる．
    \begin{align*}
		& (pc = l \wedge pc_i' = l \wedge \neg b \wedge same(V_i)) \\
		\vee \quad & (pc = l \wedge pc_i' = l' \wedge b \wedge same(V_i))
		\end{align*}

- **Lock**

    文 $\textbf{lock}(v)$ は，$v=0$ が真である場合には $v$ の値が1に変わることを除けば $\textbf{wait}(v=0)$ と似た処理である．
    この文は，2 つ以上のプロセスが**危険領域** (critical region) に入らないようにすることで，**相互排他** (mutual exclusion) を保証するためによく利用される．
    $\mathcal{C}(l, \textbf{lock}(v), l')$ は以下の 2 つの式の論理和となる．
    \begin{align*}
    & (pc = l \wedge pc_i' = l \wedge v=1 \wedge same(V_i)) \\
    \vee \quad & (pc = l \wedge pc_i' = l' \wedge v=0 \wedge v'=1 \wedge same(V_i \setminus\{v\}))
    \end{align*}

- **Unlock**

    文 $\textbf{unlock}(v)$ は，変数 $v$ に値 0 を割り当てる．
    通常この文は，他のプロセスが危険領域に入ることを可能にする．
\[ \mathcal{C}(l, \textbf{unlock}(v), l') \equiv pc_i=l \wedge pc_i' = l' \wedge v' = 0 \wedge same(V_i \setminus \{v\}) \]

#### Example 3.4
2 つのプロセス $P_0$ と $P_1$ をもつ簡単な相互排他プログラムを考える．
\[ P = m: \textbf{cobegin } P_0 \Vert P_1 \textbf{ coend } m' \]

ここで，$P_0$ および $P_1$ は以下のように与えられる．

<center>
<img src="../img/lec03-fig1.png" width="350">
</center>

プログラム $P$ のプログラムカウンタ $pc$ は，$P$ の開始点のラベル $m$，$P$ の終了点のラベル $m'$，そして $P_1$ と $P_2$ がアクティブな時の $pc$ の値である $\textbf{susp}$ の 3 つの値のみをとる．
各プロセス $P_i$ は，ラベル $l_i$，$l_i'$，$NC_i$，$CR_i$ そして $\textbf{susp}$ の値をとるプログラムカウンタ $pc_i$ をもつ．
2 つのプロセスは，1 つの変数 $turn$ を共有している．
したがって，$V = V_0 = V_1 = \{turn\}$ であり，$PC = \{pc, pc_0, pc_1\}$ となる．
プロセス $P_i$ のプログラムカウンタの値が $CR_i$ のとき，そのプロセスは危険領域にある，
両方のプロセスが同時に危険領域に入ることはできない．
プログラムカウンタの値が $NC_i$ の場合，プロセスは危険領域ではない．
この場合，プロセスは危険領域に排他的に入るため，$turn=i$ となるまで待つ．

$P$ の初期状態は以下の式で表される．
\[ \mathcal{S}_0(V, PC) \equiv pc = m \wedge pc_0 = \textbf{susp} \wedge pc_1 = \textbf{susp}. \]

$turn$ の値には制限がないことに注意してほしい．
したがって，その初期値は 0 でも 1 でもよい．
変換手続き $\mathcal{C}$ を適用すると，$P$ の遷移関係の式 $\mathcal{R}(V, PC, V', PC')$ を以下の 4 つの式の論理和として得ることができる．

\begin{align*}
           & (pc = m \wedge pc_0' = l_0 \wedge pc_1' = l_1 \wedge pc' = \textbf{susp})\\
\vee \quad & (pc_0 = l_0' \wedge pc_1 = l_1' \wedge pc' = m' \wedge pc_0' = \textbf{susp} \wedge pc_i' = \textbf{susp})\\
\vee \quad & (\mathcal{C}(l_0, P_0, l_0') \wedge same(V \setminus V_0) \wedge same(PC \setminus \{pc_0\}))\\
\vee \quad & (\mathcal{C}(l_1, P_1, l_1') \wedge same(V \setminus V_1) \wedge same(PC \setminus \{pc_1\}))\\
\end{align*}

それぞれのプロセス $P_i$ について，$\mathcal{C}(l_i, P_i, l_i')$ は以下の論理和となる．

\begin{align*}
           & (pc_i = l_i \wedge pc_i' = NC_i \wedge true \wedge same(turn))\\
\vee \quad & (pc_i = NC_i \wedge pc_i' = CR_i \wedge turn = i \wedge same(turn))\\
\vee \quad & (pc_i = CR_i \wedge pc_i' = l_i \wedge turn' = (i+2) mod 2)\\
\vee \quad & (pc_i = NC_i \wedge pc_i' = NC_i \wedge turn \neq i \wedge same(turn))\\
\vee \quad & (pc_i = l_i \wedge pc_i = i_i' \wedge false \wedge same(turn))
\end{align*}

式 $\mathcal{S}_0$ および $\mathcal{R}$ からクリプキ構造を得ることができる．
そして，その状態空間を調べることで，プロセスが同時に危険領域に入ることはないことは容易にわかる．
したがってこのプログラムは，要求された相互排除特性を保証している．
しかしながら，このプログラムに飢餓が起こらないことは保証できない．
なぜなら，一方のプロセスは危険領域に入ることができずに，もう一方のプロセスは永遠に危険領域に留まることが認められるからである．
後に，このような性質を定式化し，モデル化して検証するための方法を示す．

### 遷移の粒度
並行システムをモデル化する際には，遷移の**粒度** (granularity) をどう決めるかが重要である．
**原子的** (atomic) な遷移を特定することは重要である．
ここで遷移が原子的であるというのは，その遷移を部分的に実行しただけでは，システムの観察可能な状態が得られないという意味を指す．

よくある誤りは，あまりにも遷移を荒く定義してしまうことである．
この場合，クリプキ構造に観測可能な状態が含まれていない可能性がある．
その結果，モデル検査のような検証技術では，重要なエラーを見つけることができない場合がある．

また，粒度が細かすぎる場合にも問題が生じる．
この場合，遷移の相互作用により，実際のシステムでは到達できない新しい状態を作り出すことがある．
その結果，モデル検査は，実際には決して発生しない偽のエラーを発見することがある．

粒度が粗すぎる例として，2 つの変数 $x$ と $y$ と，並列に実行可能な以下の 2 つの遷移 $\alpha$ と $\beta$ をもつシステムを考えてみよう．

\begin{alignat*}{3}
	& \alpha: & \quad & x := x+y & \quad & \\
	& \beta:  & \quad & y := y+x & \quad &
\end{alignat*}

ここで，初期状態は $x = 1 \wedge y = 2$ とする．

また，同じ遷移の**きめ細やかな** (finer-grained) 実装も考えてみよう．
この実装では，メモリアドレスとレジスタの間のロード，追加，格納にアセンブリ言語の命令を使用している．

\begin{alignat*}{4}
& \alpha_0: & \quad & \text{load } R_1,x  & \qquad & \beta_0: & \quad & \text{load } R_2,y \\
& \alpha_1: & \quad & \text{add } R_1,y   & \qquad & \beta_1: & \quad & \text{add } R_2,x \\
& \alpha_2: & \quad & \text{store } R_1,x & \qquad & \beta_2: & \quad & \text{store } R_2,y \\
\end{alignat*}

$\alpha$，そして $\beta$ と実行すると，$x = 3 \wedge y = 5$ という状態になる．
逆に $\beta$ が $\alpha$ の前に実行されると $x = 4 \wedge y = 3$ という状態を得る．
一方で，仮にきめ細やかな実装が $\alpha_0\beta_0\alpha_1\beta_1\alpha_2\beta_2$ という順序で実行されると，結果は $x = 3 \wedge y = 3$ である．

仮に，$x = 3 \wedge y = 3$ が，システムの所望の性質を満たさなかったとする．

システムが $\alpha$ と $\beta$ という遷移によって実装されているとすると，$x=3$ と $y=3$ を同時に満たすことはない．
しかし，きめ細やかな遷移 $\alpha_0$, $\alpha_1$, $\alpha_2$, $\beta_0$, $\beta_1$, $\beta_2$ でモデル化した場合，システムが正しくないという間違った結論になるかもしれない．

次に，システムが $\alpha_0$, $\alpha_1$, $\alpha_2$, $\beta_0$, $\beta_1$, $\beta_2$ を用いて実装されていたと仮定すると，$x=3$ と $y=3$ を満たす状態は到達可能である．
ここで，システムを $\alpha$ と $\beta$ でモデル化した場合，システムが正しいという誤った結論になるかもしれない．

プログラムのテキストや回路図から論理式を抽出することはコンパイル作業とみなすことができるが，このタスクはこのような粒度を考慮する必要がある．

### 公平性
モデルに欠けている詳細を補うために，どのように非決定性を利用するかについて示してきた．
例として，並行プロセスのモデルを思い出して，次のような形式の並行プログラム $P$ を考えてみよう．
\[ \textbf{cobegin } P_1 || P_2 || \ldots || P_n \textbf{ coend} \]

実際のシステムで観測される交互実行は，$P_1$ から $P_n$ までのプロセスに，ある特定の決定的な交互実行を定めるスケジューラによって管理されているかもしれない．
それにもかかわらず，我々はスケジューラのモデル化を控えている．
これは，スケジューラの複雑さのためだったり，あるいは，スケジューラに依存せず，幅広いシステムにおいてプログラム $P$ を検証したいからだったり，いろいろな理由がある．
そのため，我々のモデルではプロセスの文のいかなる交互実行も許容し，実際のシステムの振る舞いを上方近似している．
上方近似の副作用として，望ましくない動作がモデルに追加されることがある．
この例で考えると，このモデルには，実際のシステムでは決して観測されない異常なパスが含まれている．
例えばこのモデルは，他のプロセスが無限に中断されている一方で，プロセスの1つだけが実行されるパスを許容している．
したがって，このモデルではプロセスの飢餓が生じている．

望まない振る舞いを排除するためにクリプキ構造へと制約を加える方法は数多くある．
ここでは，**公平性制約** (fairness constraint) に焦点を当てる．
形式的には，公平なクリプキ構造 $M$ は 6 組 $M = (S, S_0, R, AP, L, F)$ である．ここで，

1. $S$, $S_0$, $R$, $AP$, そして $L$ これまでの定義と同様である．
2. $F \subseteq 2^S$ は公平性制約の集合である．

$F = \{F_1, F_2, \ldots \}$ とする．ここで， $F_j$ は $S$ の部分集合である．
$s_0, s_1, \ldots$ を $M$ のパス $\pi$ を構成する状態とする．
それぞれの公平性制約 $F_j \in F$ に対して，$s_i \in F_j$ がパス $\pi$ 上に無限に多く現れるとき，パス $\pi$ は**公平** (fair) であるという．
これ以降，$M$ の公平なパスのみを考えるものとする．

上記の例では，以下のようにプロセスの飢餓を防ぐことができる．
プロセス $P_i$ が遷移するよう選択された状態を $\sigma_i$ とラベル付けする．
以下の公平性制約を用いる．
\[ \{s \in S | \sigma_1 \in L(s)\}, \ldots , \{s \in S | \sigma_n \in L(s)\} \]

得られた公平なクリプキ構造では，全てのプロセスが**無限にしばしば** (infinitely often) 実行されるようスケジュールされることが要求される．

!!! Note "問題 3.1 (特性関数)"
    特性関数は遷移関係や状態集合を定義するために用いられる．

    1. 以下の遷移関係の正確な特性関数を記述せよ．

      \[ T: \{1,\ldots,10\} = \{(1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,5) \} \]

    2. 関係 $T$ は左完全であるか答えよ．
    3. 関係 $T$ の反射推移閉包 (reflective transitive closure) を求めよ．

!!! Note "問題 3.2 (Verilog のモデル化)"
    この演習問題の目的は，遷移システムのモデル化に自信を持つことである．
    この問題では，Verilog ハードウェア記述言語 (Verilog HDL) で与えられた回路記述のセマンティクスを形式化する．
    まず，Verilog HDL のセマンティクスの非形式的な記述を見てもらいたい．

    1. Verilog HDL では 2 種類の代入演算子を区別している．
    $=$ 演算子によるブロッキング代入と，$<=$ 演算子によるノンブロッキング代入である．
    その違いを（非形式的に）説明せよ．
    2. 以下の Verilog コードの断片に対する遷移システムを定義せよ．
    なお，クロックはすべての遷移で立ち上がると仮定する．

    \begin{align*}
        &\textbf{input} \ \text{clk};\\
        &\textbf{reg} \ \text{[31:0] A, B};\\
        &\\
        &\textbf{always} \ \text{@(} \textbf{posedge}\ \text{clk)}\ \textbf{begin};\\
        &\quad \text{A = B};\\
        &\quad \text{B = A};\\
        &\textbf{end}
    \end{align*}

    3. 上記の Verilog コードの $=$ 演算子を $<=$ で置き換えた場合の遷移システムを定義せよ．
    4. $\textbf{reg}$ キーワードで定義された信号が，モデルにおいて常に状態変数となるわけではない．理由を説明し，例を示せ．
